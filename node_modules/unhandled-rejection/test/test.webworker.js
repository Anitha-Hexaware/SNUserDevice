/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var isWebWorker = typeof WorkerGlobalScope !== "undefined";
	var isNode = typeof process !== "undefined" && process.browser !== true;
	var isBrowser = !isNode && !isWebWorker && typeof document !== "undefined";

	var environmentName = "";

	if (isWebWorker) {
		environmentName = "WebWorker";
	} else if (isBrowser) {
		environmentName = "Browser";
	} else if (isNode) {
		environmentName = "Node";
	} else {
		environmentName = "Unknown environment";
	}

	function supportsWebWorkers() {
		return !!window.Worker;
	}

	if (isBrowser || isWebWorker) {
		var debug = __webpack_require__(2);
		debug.enable("*");
	}

	var unhandledRejection = __webpack_require__(5);

	var emitter = unhandledRejection();

	emitter.on("unhandledRejection", function (error, promise) {
		console.log("Caught an error in <" + environmentName + ">! " + error.message);
	});

	var BPromise = __webpack_require__(9);
	var QPromise = __webpack_require__(11);
	var WPromise = __webpack_require__(13);
	var YPromise = __webpack_require__(33);

	/* Workaround for stefanpenner/es6-promise#183 */
	var _nativePromise = Promise;
	var EPromise = __webpack_require__(34).Promise;
	Promise = _nativePromise;

	Promise.resolve().then(function () {
		console.log("Throwing Native...");
		throw new Error("Native");
	});

	BPromise.resolve().then(function () {
		console.log("Throwing Bluebird...");
		throw new Error("Bluebird");
	});

	QPromise.resolve().then(function () {
		console.log("Throwing Q...");
		throw new Error("Q");
	});

	WPromise.resolve().then(function () {
		console.log("Throwing WhenJS...");
		throw new Error("WhenJS");
	});

	YPromise.resolve().then(function () {
		console.log("Throwing Yaku...");
		throw new Error("Yaku");
	});

	/* Disabled until stefanpenner/es6-promise#70 is resolved
	EPromise.resolve().then(() => {
		console.log("Throwing es6-promise...")
		throw new Error("es6-promise")
	});
	*/

	if (isBrowser && supportsWebWorkers) {
		var worker = new Worker("test.webworker.js");
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 1 */
/***/ function(module, exports) {

	'use strict';

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = __webpack_require__(3);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

	/**
	 * Colors.
	 */

	exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */

	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return 'WebkitAppearance' in document.documentElement.style ||
	  // is firebug? http://stackoverflow.com/a/398120/376773
	  window.console && (console.firebug || console.exception && console.table) ||
	  // is firefox >= v31?
	  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	  navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
	}

	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */

	exports.formatters.j = function (v) {
	  return JSON.stringify(v);
	};

	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */

	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;

	  args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

	  if (!useColors) return args;

	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function (match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });

	  args.splice(lastC, 0, c);
	  return args;
	}

	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */

	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === (typeof console === 'undefined' ? 'undefined' : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
	}

	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */

	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch (e) {}
	}

	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */

	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch (e) {}
	  return r;
	}

	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */

	exports.enable(load());

	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */

	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */

	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(4);

	/**
	 * The currently active debug mode names, and names to skip.
	 */

	exports.names = [];
	exports.skips = [];

	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */

	exports.formatters = {};

	/**
	 * Previously assigned color.
	 */

	var prevColor = 0;

	/**
	 * Previous log timestamp.
	 */

	var prevTime;

	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */

	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}

	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */

	function debug(namespace) {

	  // define the `disabled` version
	  function disabled() {}
	  disabled.enabled = false;

	  // define the `enabled` version
	  function enabled() {

	    var self = enabled;

	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;

	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();

	    var args = Array.prototype.slice.call(arguments);

	    args[0] = exports.coerce(args[0]);

	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }

	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);

	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });

	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;

	  var fn = exports.enabled(namespace) ? enabled : disabled;

	  fn.namespace = namespace;

	  return fn;
	}

	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */

	function enable(namespaces) {
	  exports.save(namespaces);

	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;

	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}

	/**
	 * Disable debug output.
	 *
	 * @api public
	 */

	function disable() {
	  exports.enable('');
	}

	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */

	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */

	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Helpers.
	 */

	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */

	module.exports = function (val, options) {
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long ? long(val) : short(val);
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function long(ms) {
	  return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(6);

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var debug = __webpack_require__(2)("unhandled-rejection");
	var EventEmitter = __webpack_require__(7).EventEmitter;
	var rejectionStore = __webpack_require__(8);

	var unhandledTimeout = 60 * 1000;
	var unhandledPromises = [];

	module.exports = function () {
		var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

		var emitter = new EventEmitter();
		var store = rejectionStore(options.timeout);

		function extractPromiseRejectionEvent(event) {
			var errorData = {};

			if (event.detail != null && event.detail.reason != null) {
				errorData.error = event.detail.reason;
			} else if (event.reason != null) {
				errorData.error = event.reason;
			}

			if (event.detail != null && event.detail.promise != null) {
				errorData.promise = event.detail.promise;
			} else if (event.promise != null) {
				errorData.promise = event.promise;
			}

			return errorData;
		}

		function handleEvent(event, errorData) {
			if (event != null && event.preventDefault != null && typeof event.preventDefault === "function") {
				event.preventDefault();
			}

			if (errorData == null) {
				if (event != null) {
					errorData = extractPromiseRejectionEvent(event);
				}
			}

			return errorData;
		}

		function deduplicateError(errorData) {
			/* This is to deal with the case where an unhandled rejection comes in through
	   * more than one event interface, eg. in browser code. It returns a boolean
	   * indicating whether to continue the emitting process.
	   */
			return !store.exists(errorData);
		}

		function handleUnhandledRejection(event, errorData) {


			var normalizedErrorData = handleEvent(event, errorData);

			if (deduplicateError(normalizedErrorData)) {
				store.register(normalizedErrorData);


				emitter.emit("unhandledRejection", normalizedErrorData.error, normalizedErrorData.promise);
			} else {

			}
		}

		function handleRejectionHandled(event, errorData) {

			var normalizedErrorData = handleEvent(event, errorData);
			store.unregister(normalizedErrorData);


			emitter.emit("rejectionHandled", normalizedErrorData.error, normalizedErrorData.promise);
		}

		function onunhandledrejectionHandler(reason, promise) {
			if (promise != null && promise.then != null) {
				/* First argument is an error. */
				handleUnhandledRejection(null, { error: reason, promise: promise });
			} else {
				/* First argument is an event. */
				handleUnhandledRejection(reason);
			}
		}

		function onrejectionhandledHandler(promise) {
			if (promise.then != null) {
				/* First argument is a Promise. */
				var errorData = store.find(promise);

				if (errorData != null) {
					handleRejectionHandled(null, errorData);
				}
			} else {
				/* First argument is an event. */
				handleRejectionHandled(promise);
			}
		}

		function configureContextHandlers(context) {
			if (typeof context.onunhandledrejection === "function") {
				(function () {

					var _oldHandler = context.onunhandledrejection;
					context.onunhandledrejection = function (reason, promise) {
						onunhandledrejectionHandler(reason, promise);
						_oldHandler(event);
					};
				})();
			} else {
				context.onunhandledrejection = onunhandledrejectionHandler;
			}

			if (typeof context.onrejectionhandled === "function") {
				(function () {

					var _oldHandler = context.onrejectionhandled;
					context.onrejectionhandled = function (promise) {
						onrejectionhandledHandler(promise);
						_oldHandler(promise);
					};
				})();
			} else {
				context.onrejectionhandled = onrejectionhandledHandler;
			}
		}

		/* Bundlers like Webpack will shim `process`, but set its `.browser` property to `true`. */
		var isWebWorker = typeof WorkerGlobalScope !== "undefined";
		var isNode = typeof process !== "undefined" && process.browser !== true;
		var isBrowser = !isNode && !isWebWorker && typeof document !== "undefined";

		if (isNode) {


			/* Bluebird, ES6 in Node.js */
			process.on("unhandledRejection", function (error, promise) {
				var errorData = {
					error: error,
					promise: promise
				};

				handleUnhandledRejection(null, errorData);
			});

			process.on("rejectionHandled", function (promise) {
				var errorData = store.find(promise);

				if (errorData != null) {
					handleRejectionHandled(null, errorData);
				}
			});
		} else if (isWebWorker) {


			/* Yaku, Bluebird
	   * The Bluebird documentation says self.addEventListener, but it seems to use on* handlers instead. */
			configureContextHandlers(self);

			/* WHATWG */
			self.addEventListener("unhandledrejection", handleUnhandledRejection);
			self.addEventListener("rejectionhandled", handleRejectionHandled);

			/* WhenJS (note the capitalization) - currently broken */
			self.addEventListener("unhandledRejection", handleUnhandledRejection);
			self.addEventListener("rejectionHandled", handleRejectionHandled);
		} else if (isBrowser) {

			// FIXME: Native Promises broken?

			if (window.addEventListener != null) {


				/* Bluebird, WHATWG */
				window.addEventListener("unhandledrejection", handleUnhandledRejection);
				window.addEventListener("rejectionhandled", handleRejectionHandled);

				/* WhenJS (note the capitalization) - currently broken */
				window.addEventListener("unhandledRejection", handleUnhandledRejection);
				window.addEventListener("rejectionHandled", handleRejectionHandled);
			}

			/* We will need to attempt to catch unhandled rejections using both the modern and
	   * legacy APIs, because Yaku only supports the latter, *even* in modern browsers.
	   */


			/* Bluebird (Legacy API), WHATWG (Legacy API), Yaku */
			configureContextHandlers(window);
		}

		return emitter;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function (n) {
	  if (!isNumber(n) || n < 0 || isNaN(n)) throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function (type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events) this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler)) return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++) {
	      listeners[i].apply(this, args);
	    }
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function (type, listener) {
	  var m;

	  if (!isFunction(listener)) throw TypeError('listener must be a function');

	  if (!this._events) this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener) this.emit('newListener', type, isFunction(listener.listener) ? listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' + 'leak detected. %d listeners added. ' + 'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function (type, listener) {
	  if (!isFunction(listener)) throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function (type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener)) throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type]) return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener || isFunction(list.listener) && list.listener === listener) {
	    delete this._events[type];
	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener || list[i].listener && list[i].listener === listener) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0) return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener) this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function (type) {
	  var key, listeners;

	  if (!this._events) return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0) this._events = {};else if (this._events[type]) delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length) {
	      this.removeListener(type, listeners[listeners.length - 1]);
	    }
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function (type) {
	  var ret;
	  if (!this._events || !this._events[type]) ret = [];else if (isFunction(this._events[type])) ret = [this._events[type]];else ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function (type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener)) return 1;else if (evlistener) return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function (emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';

	module.exports = function () {
		var timeout = arguments.length <= 0 || arguments[0] === undefined ? 60 : arguments[0];

		var rejections = [];

		return {
			register: function register(errorData) {
				var _this = this;

				rejections.push(errorData);

				setTimeout(function () {
					_this.unregister(errorData);
				}, timeout * 1000);
			},
			unregister: function unregister(errorData) {
				var errorIndex = rejections.indexOf(errorData);

				if (errorIndex !== -1) {
					rejections.splice(errorIndex, 1);
				}
			},
			exists: function exists(errorData) {
				return rejections.some(function (item) {
					return item.promise === errorData.promise && item.error === errorData.error;
				});
			},
			find: function find(promise) {
				return rejections.find(function (item) {
					return item.promise === promise;
				});
			}
		};
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {"use strict";var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol?"symbol":typeof obj;}; /* @preserve
	 * The MIT License (MIT)
	 *
	 * Copyright (c) 2013-2015 Petka Antonov
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 *
	 */ /**
	 * bluebird build version 3.4.1
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
	*/!function(e){if("object"==( false?"undefined":_typeof(exports))&&"undefined"!=typeof module)module.exports=e();else if(true)!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (e), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e();}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f;}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e);},l,l.exports,e,t,n,r);}return n[o].exports;}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++){s(r[o]);}return s;}({1:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise){var SomePromiseArray=Promise._SomePromiseArray;function any(promises){var ret=new SomePromiseArray(promises);var promise=ret.promise();ret.setHowMany(1);ret.setUnwrap();ret.init();return promise;}Promise.any=function(promises){return any(promises);};Promise.prototype.any=function(){return any(this);};};},{}],2:[function(_dereq_,module,exports){"use strict";var firstLineError;try{throw new Error();}catch(e){firstLineError=e;}var schedule=_dereq_("./schedule");var Queue=_dereq_("./queue");var util=_dereq_("./util");function Async(){this._customScheduler=false;this._isTickUsed=false;this._lateQueue=new Queue(16);this._normalQueue=new Queue(16);this._haveDrainedQueues=false;this._trampolineEnabled=true;var self=this;this.drainQueues=function(){self._drainQueues();};this._schedule=schedule;}Async.prototype.setScheduler=function(fn){var prev=this._schedule;this._schedule=fn;this._customScheduler=true;return prev;};Async.prototype.hasCustomScheduler=function(){return this._customScheduler;};Async.prototype.enableTrampoline=function(){this._trampolineEnabled=true;};Async.prototype.disableTrampolineIfNecessary=function(){if(util.hasDevTools){this._trampolineEnabled=false;}};Async.prototype.haveItemsQueued=function(){return this._isTickUsed||this._haveDrainedQueues;};Async.prototype.fatalError=function(e,isNode){if(isNode){process.stderr.write("Fatal "+(e instanceof Error?e.stack:e)+"\n");process.exit(2);}else {this.throwLater(e);}};Async.prototype.throwLater=function(fn,arg){if(arguments.length===1){arg=fn;fn=function fn(){throw arg;};}if(typeof setTimeout!=="undefined"){setTimeout(function(){fn(arg);},0);}else try{this._schedule(function(){fn(arg);});}catch(e){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");}};function AsyncInvokeLater(fn,receiver,arg){this._lateQueue.push(fn,receiver,arg);this._queueTick();}function AsyncInvoke(fn,receiver,arg){this._normalQueue.push(fn,receiver,arg);this._queueTick();}function AsyncSettlePromises(promise){this._normalQueue._pushOne(promise);this._queueTick();}if(!util.hasDevTools){Async.prototype.invokeLater=AsyncInvokeLater;Async.prototype.invoke=AsyncInvoke;Async.prototype.settlePromises=AsyncSettlePromises;}else {Async.prototype.invokeLater=function(fn,receiver,arg){if(this._trampolineEnabled){AsyncInvokeLater.call(this,fn,receiver,arg);}else {this._schedule(function(){setTimeout(function(){fn.call(receiver,arg);},100);});}};Async.prototype.invoke=function(fn,receiver,arg){if(this._trampolineEnabled){AsyncInvoke.call(this,fn,receiver,arg);}else {this._schedule(function(){fn.call(receiver,arg);});}};Async.prototype.settlePromises=function(promise){if(this._trampolineEnabled){AsyncSettlePromises.call(this,promise);}else {this._schedule(function(){promise._settlePromises();});}};}Async.prototype.invokeFirst=function(fn,receiver,arg){this._normalQueue.unshift(fn,receiver,arg);this._queueTick();};Async.prototype._drainQueue=function(queue){while(queue.length()>0){var fn=queue.shift();if(typeof fn!=="function"){fn._settlePromises();continue;}var receiver=queue.shift();var arg=queue.shift();fn.call(receiver,arg);}};Async.prototype._drainQueues=function(){this._drainQueue(this._normalQueue);this._reset();this._haveDrainedQueues=true;this._drainQueue(this._lateQueue);};Async.prototype._queueTick=function(){if(!this._isTickUsed){this._isTickUsed=true;this._schedule(this.drainQueues);}};Async.prototype._reset=function(){this._isTickUsed=false;};module.exports=Async;module.exports.firstLineError=firstLineError;},{"./queue":26,"./schedule":29,"./util":36}],3:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL,tryConvertToPromise,debug){var calledBind=false;var rejectThis=function rejectThis(_,e){this._reject(e);};var targetRejected=function targetRejected(e,context){context.promiseRejectionQueued=true;context.bindingPromise._then(rejectThis,rejectThis,null,this,e);};var bindingResolved=function bindingResolved(thisArg,context){if((this._bitField&50397184)===0){this._resolveCallback(context.target);}};var bindingRejected=function bindingRejected(e,context){if(!context.promiseRejectionQueued)this._reject(e);};Promise.prototype.bind=function(thisArg){if(!calledBind){calledBind=true;Promise.prototype._propagateFrom=debug.propagateFromFunction();Promise.prototype._boundValue=debug.boundValueFunction();}var maybePromise=tryConvertToPromise(thisArg);var ret=new Promise(INTERNAL);ret._propagateFrom(this,1);var target=this._target();ret._setBoundTo(maybePromise);if(maybePromise instanceof Promise){var context={promiseRejectionQueued:false,promise:ret,target:target,bindingPromise:maybePromise};target._then(INTERNAL,targetRejected,undefined,ret,context);maybePromise._then(bindingResolved,bindingRejected,undefined,ret,context);ret._setOnCancel(maybePromise);}else {ret._resolveCallback(target);}return ret;};Promise.prototype._setBoundTo=function(obj){if(obj!==undefined){this._bitField=this._bitField|2097152;this._boundTo=obj;}else {this._bitField=this._bitField&~2097152;}};Promise.prototype._isBound=function(){return (this._bitField&2097152)===2097152;};Promise.bind=function(thisArg,value){return Promise.resolve(value).bind(thisArg);};};},{}],4:[function(_dereq_,module,exports){"use strict";var old;if(typeof Promise!=="undefined")old=Promise;function noConflict(){try{if(Promise===bluebird)Promise=old;}catch(e){}return bluebird;}var bluebird=_dereq_("./promise")();bluebird.noConflict=noConflict;module.exports=bluebird;},{"./promise":22}],5:[function(_dereq_,module,exports){"use strict";var cr=Object.create;if(cr){var callerCache=cr(null);var getterCache=cr(null);callerCache[" size"]=getterCache[" size"]=0;}module.exports=function(Promise){var util=_dereq_("./util");var canEvaluate=util.canEvaluate;var isIdentifier=util.isIdentifier;var getMethodCaller;var getGetter;if(false){var makeMethodCaller=function makeMethodCaller(methodName){return new Function("ensureMethod","                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g,methodName))(ensureMethod);};var makeGetter=function makeGetter(propertyName){return new Function("obj","                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName",propertyName));};var getCompiled=function getCompiled(name,compiler,cache){var ret=cache[name];if(typeof ret!=="function"){if(!isIdentifier(name)){return null;}ret=compiler(name);cache[name]=ret;cache[" size"]++;if(cache[" size"]>512){var keys=Object.keys(cache);for(var i=0;i<256;++i){delete cache[keys[i]];}cache[" size"]=keys.length-256;}}return ret;};getMethodCaller=function getMethodCaller(name){return getCompiled(name,makeMethodCaller,callerCache);};getGetter=function getGetter(name){return getCompiled(name,makeGetter,getterCache);};}function ensureMethod(obj,methodName){var fn;if(obj!=null)fn=obj[methodName];if(typeof fn!=="function"){var message="Object "+util.classString(obj)+" has no method '"+util.toString(methodName)+"'";throw new Promise.TypeError(message);}return fn;}function caller(obj){var methodName=this.pop();var fn=ensureMethod(obj,methodName);return fn.apply(obj,this);}Promise.prototype.call=function(methodName){var args=[].slice.call(arguments,1);;if(false){if(canEvaluate){var maybeCaller=getMethodCaller(methodName);if(maybeCaller!==null){return this._then(maybeCaller,undefined,undefined,args,undefined);}}}args.push(methodName);return this._then(caller,undefined,undefined,args,undefined);};function namedGetter(obj){return obj[this];}function indexedGetter(obj){var index=+this;if(index<0)index=Math.max(0,index+obj.length);return obj[index];}Promise.prototype.get=function(propertyName){var isIndex=typeof propertyName==="number";var getter;if(!isIndex){if(canEvaluate){var maybeGetter=getGetter(propertyName);getter=maybeGetter!==null?maybeGetter:namedGetter;}else {getter=namedGetter;}}else {getter=indexedGetter;}return this._then(getter,undefined,undefined,propertyName,undefined);};};},{"./util":36}],6:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,apiRejection,debug){var util=_dereq_("./util");var tryCatch=util.tryCatch;var errorObj=util.errorObj;var async=Promise._async;Promise.prototype["break"]=Promise.prototype.cancel=function(){if(!debug.cancellation())return this._warn("cancellation is disabled");var promise=this;var child=promise;while(promise.isCancellable()){if(!promise._cancelBy(child)){if(child._isFollowing()){child._followee().cancel();}else {child._cancelBranched();}break;}var parent=promise._cancellationParent;if(parent==null||!parent.isCancellable()){if(promise._isFollowing()){promise._followee().cancel();}else {promise._cancelBranched();}break;}else {if(promise._isFollowing())promise._followee().cancel();child=promise;promise=parent;}}};Promise.prototype._branchHasCancelled=function(){this._branchesRemainingToCancel--;};Promise.prototype._enoughBranchesHaveCancelled=function(){return this._branchesRemainingToCancel===undefined||this._branchesRemainingToCancel<=0;};Promise.prototype._cancelBy=function(canceller){if(canceller===this){this._branchesRemainingToCancel=0;this._invokeOnCancel();return true;}else {this._branchHasCancelled();if(this._enoughBranchesHaveCancelled()){this._invokeOnCancel();return true;}}return false;};Promise.prototype._cancelBranched=function(){if(this._enoughBranchesHaveCancelled()){this._cancel();}};Promise.prototype._cancel=function(){if(!this.isCancellable())return;this._setCancelled();async.invoke(this._cancelPromises,this,undefined);};Promise.prototype._cancelPromises=function(){if(this._length()>0)this._settlePromises();};Promise.prototype._unsetOnCancel=function(){this._onCancelField=undefined;};Promise.prototype.isCancellable=function(){return this.isPending()&&!this.isCancelled();};Promise.prototype._doInvokeOnCancel=function(onCancelCallback,internalOnly){if(util.isArray(onCancelCallback)){for(var i=0;i<onCancelCallback.length;++i){this._doInvokeOnCancel(onCancelCallback[i],internalOnly);}}else if(onCancelCallback!==undefined){if(typeof onCancelCallback==="function"){if(!internalOnly){var e=tryCatch(onCancelCallback).call(this._boundValue());if(e===errorObj){this._attachExtraTrace(e.e);async.throwLater(e.e);}}}else {onCancelCallback._resultCancelled(this);}}};Promise.prototype._invokeOnCancel=function(){var onCancelCallback=this._onCancel();this._unsetOnCancel();async.invoke(this._doInvokeOnCancel,this,onCancelCallback);};Promise.prototype._invokeInternalOnCancel=function(){if(this.isCancellable()){this._doInvokeOnCancel(this._onCancel(),true);this._unsetOnCancel();}};Promise.prototype._resultCancelled=function(){this.cancel();};};},{"./util":36}],7:[function(_dereq_,module,exports){"use strict";module.exports=function(NEXT_FILTER){var util=_dereq_("./util");var getKeys=_dereq_("./es5").keys;var tryCatch=util.tryCatch;var errorObj=util.errorObj;function catchFilter(instances,cb,promise){return function(e){var boundTo=promise._boundValue();predicateLoop: for(var i=0;i<instances.length;++i){var item=instances[i];if(item===Error||item!=null&&item.prototype instanceof Error){if(e instanceof item){return tryCatch(cb).call(boundTo,e);}}else if(typeof item==="function"){var matchesPredicate=tryCatch(item).call(boundTo,e);if(matchesPredicate===errorObj){return matchesPredicate;}else if(matchesPredicate){return tryCatch(cb).call(boundTo,e);}}else if(util.isObject(e)){var keys=getKeys(item);for(var j=0;j<keys.length;++j){var key=keys[j];if(item[key]!=e[key]){continue predicateLoop;}}return tryCatch(cb).call(boundTo,e);}}return NEXT_FILTER;};}return catchFilter;};},{"./es5":13,"./util":36}],8:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise){var longStackTraces=false;var contextStack=[];Promise.prototype._promiseCreated=function(){};Promise.prototype._pushContext=function(){};Promise.prototype._popContext=function(){return null;};Promise._peekContext=Promise.prototype._peekContext=function(){};function Context(){this._trace=new Context.CapturedTrace(peekContext());}Context.prototype._pushContext=function(){if(this._trace!==undefined){this._trace._promiseCreated=null;contextStack.push(this._trace);}};Context.prototype._popContext=function(){if(this._trace!==undefined){var trace=contextStack.pop();var ret=trace._promiseCreated;trace._promiseCreated=null;return ret;}return null;};function createContext(){if(longStackTraces)return new Context();}function peekContext(){var lastIndex=contextStack.length-1;if(lastIndex>=0){return contextStack[lastIndex];}return undefined;}Context.CapturedTrace=null;Context.create=createContext;Context.deactivateLongStackTraces=function(){};Context.activateLongStackTraces=function(){var Promise_pushContext=Promise.prototype._pushContext;var Promise_popContext=Promise.prototype._popContext;var Promise_PeekContext=Promise._peekContext;var Promise_peekContext=Promise.prototype._peekContext;var Promise_promiseCreated=Promise.prototype._promiseCreated;Context.deactivateLongStackTraces=function(){Promise.prototype._pushContext=Promise_pushContext;Promise.prototype._popContext=Promise_popContext;Promise._peekContext=Promise_PeekContext;Promise.prototype._peekContext=Promise_peekContext;Promise.prototype._promiseCreated=Promise_promiseCreated;longStackTraces=false;};longStackTraces=true;Promise.prototype._pushContext=Context.prototype._pushContext;Promise.prototype._popContext=Context.prototype._popContext;Promise._peekContext=Promise.prototype._peekContext=peekContext;Promise.prototype._promiseCreated=function(){var ctx=this._peekContext();if(ctx&&ctx._promiseCreated==null)ctx._promiseCreated=this;};};return Context;};},{}],9:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,Context){var getDomain=Promise._getDomain;var async=Promise._async;var Warning=_dereq_("./errors").Warning;var util=_dereq_("./util");var canAttachTrace=util.canAttachTrace;var unhandledRejectionHandled;var possiblyUnhandledRejection;var bluebirdFramePattern=/[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;var stackFramePattern=null;var formatStack=null;var indentStackFrames=false;var printWarning;var debugging=!!(util.env("BLUEBIRD_DEBUG")!=0&&(true||util.env("BLUEBIRD_DEBUG")||util.env("NODE_ENV")==="development"));var warnings=!!(util.env("BLUEBIRD_WARNINGS")!=0&&(debugging||util.env("BLUEBIRD_WARNINGS")));var longStackTraces=!!(util.env("BLUEBIRD_LONG_STACK_TRACES")!=0&&(debugging||util.env("BLUEBIRD_LONG_STACK_TRACES")));var wForgottenReturn=util.env("BLUEBIRD_W_FORGOTTEN_RETURN")!=0&&(warnings||!!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));Promise.prototype.suppressUnhandledRejections=function(){var target=this._target();target._bitField=target._bitField&~1048576|524288;};Promise.prototype._ensurePossibleRejectionHandled=function(){if((this._bitField&524288)!==0)return;this._setRejectionIsUnhandled();async.invokeLater(this._notifyUnhandledRejection,this,undefined);};Promise.prototype._notifyUnhandledRejectionIsHandled=function(){fireRejectionEvent("rejectionHandled",unhandledRejectionHandled,undefined,this);};Promise.prototype._setReturnedNonUndefined=function(){this._bitField=this._bitField|268435456;};Promise.prototype._returnedNonUndefined=function(){return (this._bitField&268435456)!==0;};Promise.prototype._notifyUnhandledRejection=function(){if(this._isRejectionUnhandled()){var reason=this._settledValue();this._setUnhandledRejectionIsNotified();fireRejectionEvent("unhandledRejection",possiblyUnhandledRejection,reason,this);}};Promise.prototype._setUnhandledRejectionIsNotified=function(){this._bitField=this._bitField|262144;};Promise.prototype._unsetUnhandledRejectionIsNotified=function(){this._bitField=this._bitField&~262144;};Promise.prototype._isUnhandledRejectionNotified=function(){return (this._bitField&262144)>0;};Promise.prototype._setRejectionIsUnhandled=function(){this._bitField=this._bitField|1048576;};Promise.prototype._unsetRejectionIsUnhandled=function(){this._bitField=this._bitField&~1048576;if(this._isUnhandledRejectionNotified()){this._unsetUnhandledRejectionIsNotified();this._notifyUnhandledRejectionIsHandled();}};Promise.prototype._isRejectionUnhandled=function(){return (this._bitField&1048576)>0;};Promise.prototype._warn=function(message,shouldUseOwnTrace,promise){return warn(message,shouldUseOwnTrace,promise||this);};Promise.onPossiblyUnhandledRejection=function(fn){var domain=getDomain();possiblyUnhandledRejection=typeof fn==="function"?domain===null?fn:domain.bind(fn):undefined;};Promise.onUnhandledRejectionHandled=function(fn){var domain=getDomain();unhandledRejectionHandled=typeof fn==="function"?domain===null?fn:domain.bind(fn):undefined;};var disableLongStackTraces=function disableLongStackTraces(){};Promise.longStackTraces=function(){if(async.haveItemsQueued()&&!config.longStackTraces){throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");}if(!config.longStackTraces&&longStackTracesIsSupported()){var Promise_captureStackTrace=Promise.prototype._captureStackTrace;var Promise_attachExtraTrace=Promise.prototype._attachExtraTrace;config.longStackTraces=true;disableLongStackTraces=function disableLongStackTraces(){if(async.haveItemsQueued()&&!config.longStackTraces){throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");}Promise.prototype._captureStackTrace=Promise_captureStackTrace;Promise.prototype._attachExtraTrace=Promise_attachExtraTrace;Context.deactivateLongStackTraces();async.enableTrampoline();config.longStackTraces=false;};Promise.prototype._captureStackTrace=longStackTracesCaptureStackTrace;Promise.prototype._attachExtraTrace=longStackTracesAttachExtraTrace;Context.activateLongStackTraces();async.disableTrampolineIfNecessary();}};Promise.hasLongStackTraces=function(){return config.longStackTraces&&longStackTracesIsSupported();};var fireDomEvent=function(){try{var event=document.createEvent("CustomEvent");event.initCustomEvent("testingtheevent",false,true,{});util.global.dispatchEvent(event);return function(name,event){var domEvent=document.createEvent("CustomEvent");domEvent.initCustomEvent(name.toLowerCase(),false,true,event);return !util.global.dispatchEvent(domEvent);};}catch(e){}return function(){return false;};}();var fireGlobalEvent=function(){if(util.isNode){return function(){return process.emit.apply(process,arguments);};}else {if(!util.global){return function(){return false;};}return function(name){var methodName="on"+name.toLowerCase();var method=util.global[methodName];if(!method)return false;method.apply(util.global,[].slice.call(arguments,1));return true;};}}();function generatePromiseLifecycleEventObject(name,promise){return {promise:promise};}var eventToObjectGenerator={promiseCreated:generatePromiseLifecycleEventObject,promiseFulfilled:generatePromiseLifecycleEventObject,promiseRejected:generatePromiseLifecycleEventObject,promiseResolved:generatePromiseLifecycleEventObject,promiseCancelled:generatePromiseLifecycleEventObject,promiseChained:function promiseChained(name,promise,child){return {promise:promise,child:child};},warning:function warning(name,_warning){return {warning:_warning};},unhandledRejection:function unhandledRejection(name,reason,promise){return {reason:reason,promise:promise};},rejectionHandled:generatePromiseLifecycleEventObject};var activeFireEvent=function activeFireEvent(name){var globalEventFired=false;try{globalEventFired=fireGlobalEvent.apply(null,arguments);}catch(e){async.throwLater(e);globalEventFired=true;}var domEventFired=false;try{domEventFired=fireDomEvent(name,eventToObjectGenerator[name].apply(null,arguments));}catch(e){async.throwLater(e);domEventFired=true;}return domEventFired||globalEventFired;};Promise.config=function(opts){opts=Object(opts);if("longStackTraces" in opts){if(opts.longStackTraces){Promise.longStackTraces();}else if(!opts.longStackTraces&&Promise.hasLongStackTraces()){disableLongStackTraces();}}if("warnings" in opts){var warningsOption=opts.warnings;config.warnings=!!warningsOption;wForgottenReturn=config.warnings;if(util.isObject(warningsOption)){if("wForgottenReturn" in warningsOption){wForgottenReturn=!!warningsOption.wForgottenReturn;}}}if("cancellation" in opts&&opts.cancellation&&!config.cancellation){if(async.haveItemsQueued()){throw new Error("cannot enable cancellation after promises are in use");}Promise.prototype._clearCancellationData=cancellationClearCancellationData;Promise.prototype._propagateFrom=cancellationPropagateFrom;Promise.prototype._onCancel=cancellationOnCancel;Promise.prototype._setOnCancel=cancellationSetOnCancel;Promise.prototype._attachCancellationCallback=cancellationAttachCancellationCallback;Promise.prototype._execute=cancellationExecute;_propagateFromFunction=cancellationPropagateFrom;config.cancellation=true;}if("monitoring" in opts){if(opts.monitoring&&!config.monitoring){config.monitoring=true;Promise.prototype._fireEvent=activeFireEvent;}else if(!opts.monitoring&&config.monitoring){config.monitoring=false;Promise.prototype._fireEvent=defaultFireEvent;}}};function defaultFireEvent(){return false;}Promise.prototype._fireEvent=defaultFireEvent;Promise.prototype._execute=function(executor,resolve,reject){try{executor(resolve,reject);}catch(e){return e;}};Promise.prototype._onCancel=function(){};Promise.prototype._setOnCancel=function(handler){;};Promise.prototype._attachCancellationCallback=function(onCancel){;};Promise.prototype._captureStackTrace=function(){};Promise.prototype._attachExtraTrace=function(){};Promise.prototype._clearCancellationData=function(){};Promise.prototype._propagateFrom=function(parent,flags){;;};function cancellationExecute(executor,resolve,reject){var promise=this;try{executor(resolve,reject,function(onCancel){if(typeof onCancel!=="function"){throw new TypeError("onCancel must be a function, got: "+util.toString(onCancel));}promise._attachCancellationCallback(onCancel);});}catch(e){return e;}}function cancellationAttachCancellationCallback(onCancel){if(!this.isCancellable())return this;var previousOnCancel=this._onCancel();if(previousOnCancel!==undefined){if(util.isArray(previousOnCancel)){previousOnCancel.push(onCancel);}else {this._setOnCancel([previousOnCancel,onCancel]);}}else {this._setOnCancel(onCancel);}}function cancellationOnCancel(){return this._onCancelField;}function cancellationSetOnCancel(onCancel){this._onCancelField=onCancel;}function cancellationClearCancellationData(){this._cancellationParent=undefined;this._onCancelField=undefined;}function cancellationPropagateFrom(parent,flags){if((flags&1)!==0){this._cancellationParent=parent;var branchesRemainingToCancel=parent._branchesRemainingToCancel;if(branchesRemainingToCancel===undefined){branchesRemainingToCancel=0;}parent._branchesRemainingToCancel=branchesRemainingToCancel+1;}if((flags&2)!==0&&parent._isBound()){this._setBoundTo(parent._boundTo);}}function bindingPropagateFrom(parent,flags){if((flags&2)!==0&&parent._isBound()){this._setBoundTo(parent._boundTo);}}var _propagateFromFunction=bindingPropagateFrom;function _boundValueFunction(){var ret=this._boundTo;if(ret!==undefined){if(ret instanceof Promise){if(ret.isFulfilled()){return ret.value();}else {return undefined;}}}return ret;}function longStackTracesCaptureStackTrace(){this._trace=new CapturedTrace(this._peekContext());}function longStackTracesAttachExtraTrace(error,ignoreSelf){if(canAttachTrace(error)){var trace=this._trace;if(trace!==undefined){if(ignoreSelf)trace=trace._parent;}if(trace!==undefined){trace.attachExtraTrace(error);}else if(!error.__stackCleaned__){var parsed=parseStackAndMessage(error);util.notEnumerableProp(error,"stack",parsed.message+"\n"+parsed.stack.join("\n"));util.notEnumerableProp(error,"__stackCleaned__",true);}}}function checkForgottenReturns(returnValue,promiseCreated,name,promise,parent){if(returnValue===undefined&&promiseCreated!==null&&wForgottenReturn){if(parent!==undefined&&parent._returnedNonUndefined())return;if((promise._bitField&65535)===0)return;if(name)name=name+" ";var msg="a promise was created in a "+name+"handler but was not returned from it";promise._warn(msg,true,promiseCreated);}}function deprecated(name,replacement){var message=name+" is deprecated and will be removed in a future version.";if(replacement)message+=" Use "+replacement+" instead.";return warn(message);}function warn(message,shouldUseOwnTrace,promise){if(!config.warnings)return;var warning=new Warning(message);var ctx;if(shouldUseOwnTrace){promise._attachExtraTrace(warning);}else if(config.longStackTraces&&(ctx=Promise._peekContext())){ctx.attachExtraTrace(warning);}else {var parsed=parseStackAndMessage(warning);warning.stack=parsed.message+"\n"+parsed.stack.join("\n");}if(!activeFireEvent("warning",warning)){formatAndLogError(warning,"",true);}}function reconstructStack(message,stacks){for(var i=0;i<stacks.length-1;++i){stacks[i].push("From previous event:");stacks[i]=stacks[i].join("\n");}if(i<stacks.length){stacks[i]=stacks[i].join("\n");}return message+"\n"+stacks.join("\n");}function removeDuplicateOrEmptyJumps(stacks){for(var i=0;i<stacks.length;++i){if(stacks[i].length===0||i+1<stacks.length&&stacks[i][0]===stacks[i+1][0]){stacks.splice(i,1);i--;}}}function removeCommonRoots(stacks){var current=stacks[0];for(var i=1;i<stacks.length;++i){var prev=stacks[i];var currentLastIndex=current.length-1;var currentLastLine=current[currentLastIndex];var commonRootMeetPoint=-1;for(var j=prev.length-1;j>=0;--j){if(prev[j]===currentLastLine){commonRootMeetPoint=j;break;}}for(var j=commonRootMeetPoint;j>=0;--j){var line=prev[j];if(current[currentLastIndex]===line){current.pop();currentLastIndex--;}else {break;}}current=prev;}}function cleanStack(stack){var ret=[];for(var i=0;i<stack.length;++i){var line=stack[i];var isTraceLine="    (No stack trace)"===line||stackFramePattern.test(line);var isInternalFrame=isTraceLine&&shouldIgnore(line);if(isTraceLine&&!isInternalFrame){if(indentStackFrames&&line.charAt(0)!==" "){line="    "+line;}ret.push(line);}}return ret;}function stackFramesAsArray(error){var stack=error.stack.replace(/\s+$/g,"").split("\n");for(var i=0;i<stack.length;++i){var line=stack[i];if("    (No stack trace)"===line||stackFramePattern.test(line)){break;}}if(i>0){stack=stack.slice(i);}return stack;}function parseStackAndMessage(error){var stack=error.stack;var message=error.toString();stack=typeof stack==="string"&&stack.length>0?stackFramesAsArray(error):["    (No stack trace)"];return {message:message,stack:cleanStack(stack)};}function formatAndLogError(error,title,isSoft){if(typeof console!=="undefined"){var message;if(util.isObject(error)){var stack=error.stack;message=title+formatStack(stack,error);}else {message=title+String(error);}if(typeof printWarning==="function"){printWarning(message,isSoft);}else if(typeof console.log==="function"||_typeof(console.log)==="object"){console.log(message);}}}function fireRejectionEvent(name,localHandler,reason,promise){var localEventFired=false;try{if(typeof localHandler==="function"){localEventFired=true;if(name==="rejectionHandled"){localHandler(promise);}else {localHandler(reason,promise);}}}catch(e){async.throwLater(e);}if(name==="unhandledRejection"){if(!activeFireEvent(name,reason,promise)&&!localEventFired){formatAndLogError(reason,"Unhandled rejection ");}}else {activeFireEvent(name,promise);}}function formatNonError(obj){var str;if(typeof obj==="function"){str="[function "+(obj.name||"anonymous")+"]";}else {str=obj&&typeof obj.toString==="function"?obj.toString():util.toString(obj);var ruselessToString=/\[object [a-zA-Z0-9$_]+\]/;if(ruselessToString.test(str)){try{var newStr=JSON.stringify(obj);str=newStr;}catch(e){}}if(str.length===0){str="(empty array)";}}return "(<"+snip(str)+">, no stack trace)";}function snip(str){var maxChars=41;if(str.length<maxChars){return str;}return str.substr(0,maxChars-3)+"...";}function longStackTracesIsSupported(){return typeof captureStackTrace==="function";}var shouldIgnore=function shouldIgnore(){return false;};var parseLineInfoRegex=/[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;function parseLineInfo(line){var matches=line.match(parseLineInfoRegex);if(matches){return {fileName:matches[1],line:parseInt(matches[2],10)};}}function setBounds(firstLineError,lastLineError){if(!longStackTracesIsSupported())return;var firstStackLines=firstLineError.stack.split("\n");var lastStackLines=lastLineError.stack.split("\n");var firstIndex=-1;var lastIndex=-1;var firstFileName;var lastFileName;for(var i=0;i<firstStackLines.length;++i){var result=parseLineInfo(firstStackLines[i]);if(result){firstFileName=result.fileName;firstIndex=result.line;break;}}for(var i=0;i<lastStackLines.length;++i){var result=parseLineInfo(lastStackLines[i]);if(result){lastFileName=result.fileName;lastIndex=result.line;break;}}if(firstIndex<0||lastIndex<0||!firstFileName||!lastFileName||firstFileName!==lastFileName||firstIndex>=lastIndex){return;}shouldIgnore=function shouldIgnore(line){if(bluebirdFramePattern.test(line))return true;var info=parseLineInfo(line);if(info){if(info.fileName===firstFileName&&firstIndex<=info.line&&info.line<=lastIndex){return true;}}return false;};}function CapturedTrace(parent){this._parent=parent;this._promisesCreated=0;var length=this._length=1+(parent===undefined?0:parent._length);captureStackTrace(this,CapturedTrace);if(length>32)this.uncycle();}util.inherits(CapturedTrace,Error);Context.CapturedTrace=CapturedTrace;CapturedTrace.prototype.uncycle=function(){var length=this._length;if(length<2)return;var nodes=[];var stackToIndex={};for(var i=0,node=this;node!==undefined;++i){nodes.push(node);node=node._parent;}length=this._length=i;for(var i=length-1;i>=0;--i){var stack=nodes[i].stack;if(stackToIndex[stack]===undefined){stackToIndex[stack]=i;}}for(var i=0;i<length;++i){var currentStack=nodes[i].stack;var index=stackToIndex[currentStack];if(index!==undefined&&index!==i){if(index>0){nodes[index-1]._parent=undefined;nodes[index-1]._length=1;}nodes[i]._parent=undefined;nodes[i]._length=1;var cycleEdgeNode=i>0?nodes[i-1]:this;if(index<length-1){cycleEdgeNode._parent=nodes[index+1];cycleEdgeNode._parent.uncycle();cycleEdgeNode._length=cycleEdgeNode._parent._length+1;}else {cycleEdgeNode._parent=undefined;cycleEdgeNode._length=1;}var currentChildLength=cycleEdgeNode._length+1;for(var j=i-2;j>=0;--j){nodes[j]._length=currentChildLength;currentChildLength++;}return;}}};CapturedTrace.prototype.attachExtraTrace=function(error){if(error.__stackCleaned__)return;this.uncycle();var parsed=parseStackAndMessage(error);var message=parsed.message;var stacks=[parsed.stack];var trace=this;while(trace!==undefined){stacks.push(cleanStack(trace.stack.split("\n")));trace=trace._parent;}removeCommonRoots(stacks);removeDuplicateOrEmptyJumps(stacks);util.notEnumerableProp(error,"stack",reconstructStack(message,stacks));util.notEnumerableProp(error,"__stackCleaned__",true);};var captureStackTrace=function stackDetection(){var v8stackFramePattern=/^\s*at\s*/;var v8stackFormatter=function v8stackFormatter(stack,error){if(typeof stack==="string")return stack;if(error.name!==undefined&&error.message!==undefined){return error.toString();}return formatNonError(error);};if(typeof Error.stackTraceLimit==="number"&&typeof Error.captureStackTrace==="function"){Error.stackTraceLimit+=6;stackFramePattern=v8stackFramePattern;formatStack=v8stackFormatter;var captureStackTrace=Error.captureStackTrace;shouldIgnore=function shouldIgnore(line){return bluebirdFramePattern.test(line);};return function(receiver,ignoreUntil){Error.stackTraceLimit+=6;captureStackTrace(receiver,ignoreUntil);Error.stackTraceLimit-=6;};}var err=new Error();if(typeof err.stack==="string"&&err.stack.split("\n")[0].indexOf("stackDetection@")>=0){stackFramePattern=/@/;formatStack=v8stackFormatter;indentStackFrames=true;return function captureStackTrace(o){o.stack=new Error().stack;};}var hasStackAfterThrow;try{throw new Error();}catch(e){hasStackAfterThrow="stack" in e;}if(!("stack" in err)&&hasStackAfterThrow&&typeof Error.stackTraceLimit==="number"){stackFramePattern=v8stackFramePattern;formatStack=v8stackFormatter;return function captureStackTrace(o){Error.stackTraceLimit+=6;try{throw new Error();}catch(e){o.stack=e.stack;}Error.stackTraceLimit-=6;};}formatStack=function formatStack(stack,error){if(typeof stack==="string")return stack;if(((typeof error==="undefined"?"undefined":_typeof(error))==="object"||typeof error==="function")&&error.name!==undefined&&error.message!==undefined){return error.toString();}return formatNonError(error);};return null;}([]);if(typeof console!=="undefined"&&typeof console.warn!=="undefined"){printWarning=function printWarning(message){console.warn(message);};if(util.isNode&&process.stderr.isTTY){printWarning=function printWarning(message,isSoft){var color=isSoft?"\u001b[33m":"\u001b[31m";console.warn(color+message+"\u001b[0m\n");};}else if(!util.isNode&&typeof new Error().stack==="string"){printWarning=function printWarning(message,isSoft){console.warn("%c"+message,isSoft?"color: darkorange":"color: red");};}}var config={warnings:warnings,longStackTraces:false,cancellation:false,monitoring:false};if(longStackTraces)Promise.longStackTraces();return {longStackTraces:function longStackTraces(){return config.longStackTraces;},warnings:function warnings(){return config.warnings;},cancellation:function cancellation(){return config.cancellation;},monitoring:function monitoring(){return config.monitoring;},propagateFromFunction:function propagateFromFunction(){return _propagateFromFunction;},boundValueFunction:function boundValueFunction(){return _boundValueFunction;},checkForgottenReturns:checkForgottenReturns,setBounds:setBounds,warn:warn,deprecated:deprecated,CapturedTrace:CapturedTrace,fireDomEvent:fireDomEvent,fireGlobalEvent:fireGlobalEvent};};},{"./errors":12,"./util":36}],10:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise){function returner(){return this.value;}function thrower(){throw this.reason;}Promise.prototype["return"]=Promise.prototype.thenReturn=function(value){if(value instanceof Promise)value.suppressUnhandledRejections();return this._then(returner,undefined,undefined,{value:value},undefined);};Promise.prototype["throw"]=Promise.prototype.thenThrow=function(reason){return this._then(thrower,undefined,undefined,{reason:reason},undefined);};Promise.prototype.catchThrow=function(reason){if(arguments.length<=1){return this._then(undefined,thrower,undefined,{reason:reason},undefined);}else {var _reason=arguments[1];var handler=function handler(){throw _reason;};return this.caught(reason,handler);}};Promise.prototype.catchReturn=function(value){if(arguments.length<=1){if(value instanceof Promise)value.suppressUnhandledRejections();return this._then(undefined,returner,undefined,{value:value},undefined);}else {var _value=arguments[1];if(_value instanceof Promise)_value.suppressUnhandledRejections();var handler=function handler(){return _value;};return this.caught(value,handler);}};};},{}],11:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL){var PromiseReduce=Promise.reduce;var PromiseAll=Promise.all;function promiseAllThis(){return PromiseAll(this);}function PromiseMapSeries(promises,fn){return PromiseReduce(promises,fn,INTERNAL,INTERNAL);}Promise.prototype.each=function(fn){return this.mapSeries(fn)._then(promiseAllThis,undefined,undefined,this,undefined);};Promise.prototype.mapSeries=function(fn){return PromiseReduce(this,fn,INTERNAL,INTERNAL);};Promise.each=function(promises,fn){return PromiseMapSeries(promises,fn)._then(promiseAllThis,undefined,undefined,promises,undefined);};Promise.mapSeries=PromiseMapSeries;};},{}],12:[function(_dereq_,module,exports){"use strict";var es5=_dereq_("./es5");var Objectfreeze=es5.freeze;var util=_dereq_("./util");var inherits=util.inherits;var notEnumerableProp=util.notEnumerableProp;function subError(nameProperty,defaultMessage){function SubError(message){if(!(this instanceof SubError))return new SubError(message);notEnumerableProp(this,"message",typeof message==="string"?message:defaultMessage);notEnumerableProp(this,"name",nameProperty);if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor);}else {Error.call(this);}}inherits(SubError,Error);return SubError;}var _TypeError,_RangeError;var Warning=subError("Warning","warning");var CancellationError=subError("CancellationError","cancellation error");var TimeoutError=subError("TimeoutError","timeout error");var AggregateError=subError("AggregateError","aggregate error");try{_TypeError=TypeError;_RangeError=RangeError;}catch(e){_TypeError=subError("TypeError","type error");_RangeError=subError("RangeError","range error");}var methods=("join pop push shift unshift slice filter forEach some "+"every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");for(var i=0;i<methods.length;++i){if(typeof Array.prototype[methods[i]]==="function"){AggregateError.prototype[methods[i]]=Array.prototype[methods[i]];}}es5.defineProperty(AggregateError.prototype,"length",{value:0,configurable:false,writable:true,enumerable:true});AggregateError.prototype["isOperational"]=true;var level=0;AggregateError.prototype.toString=function(){var indent=Array(level*4+1).join(" ");var ret="\n"+indent+"AggregateError of:"+"\n";level++;indent=Array(level*4+1).join(" ");for(var i=0;i<this.length;++i){var str=this[i]===this?"[Circular AggregateError]":this[i]+"";var lines=str.split("\n");for(var j=0;j<lines.length;++j){lines[j]=indent+lines[j];}str=lines.join("\n");ret+=str+"\n";}level--;return ret;};function OperationalError(message){if(!(this instanceof OperationalError))return new OperationalError(message);notEnumerableProp(this,"name","OperationalError");notEnumerableProp(this,"message",message);this.cause=message;this["isOperational"]=true;if(message instanceof Error){notEnumerableProp(this,"message",message.message);notEnumerableProp(this,"stack",message.stack);}else if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor);}}inherits(OperationalError,Error);var errorTypes=Error["__BluebirdErrorTypes__"];if(!errorTypes){errorTypes=Objectfreeze({CancellationError:CancellationError,TimeoutError:TimeoutError,OperationalError:OperationalError,RejectionError:OperationalError,AggregateError:AggregateError});es5.defineProperty(Error,"__BluebirdErrorTypes__",{value:errorTypes,writable:false,enumerable:false,configurable:false});}module.exports={Error:Error,TypeError:_TypeError,RangeError:_RangeError,CancellationError:errorTypes.CancellationError,OperationalError:errorTypes.OperationalError,TimeoutError:errorTypes.TimeoutError,AggregateError:errorTypes.AggregateError,Warning:Warning};},{"./es5":13,"./util":36}],13:[function(_dereq_,module,exports){var isES5=function(){"use strict";return this===undefined;}();if(isES5){module.exports={freeze:Object.freeze,defineProperty:Object.defineProperty,getDescriptor:Object.getOwnPropertyDescriptor,keys:Object.keys,names:Object.getOwnPropertyNames,getPrototypeOf:Object.getPrototypeOf,isArray:Array.isArray,isES5:isES5,propertyIsWritable:function propertyIsWritable(obj,prop){var descriptor=Object.getOwnPropertyDescriptor(obj,prop);return !!(!descriptor||descriptor.writable||descriptor.set);}};}else {var has={}.hasOwnProperty;var str={}.toString;var proto={}.constructor.prototype;var ObjectKeys=function ObjectKeys(o){var ret=[];for(var key in o){if(has.call(o,key)){ret.push(key);}}return ret;};var ObjectGetDescriptor=function ObjectGetDescriptor(o,key){return {value:o[key]};};var ObjectDefineProperty=function ObjectDefineProperty(o,key,desc){o[key]=desc.value;return o;};var ObjectFreeze=function ObjectFreeze(obj){return obj;};var ObjectGetPrototypeOf=function ObjectGetPrototypeOf(obj){try{return Object(obj).constructor.prototype;}catch(e){return proto;}};var ArrayIsArray=function ArrayIsArray(obj){try{return str.call(obj)==="[object Array]";}catch(e){return false;}};module.exports={isArray:ArrayIsArray,keys:ObjectKeys,names:ObjectKeys,defineProperty:ObjectDefineProperty,getDescriptor:ObjectGetDescriptor,freeze:ObjectFreeze,getPrototypeOf:ObjectGetPrototypeOf,isES5:isES5,propertyIsWritable:function propertyIsWritable(){return true;}};}},{}],14:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL){var PromiseMap=Promise.map;Promise.prototype.filter=function(fn,options){return PromiseMap(this,fn,options,INTERNAL);};Promise.filter=function(promises,fn,options){return PromiseMap(promises,fn,options,INTERNAL);};};},{}],15:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,tryConvertToPromise){var util=_dereq_("./util");var CancellationError=Promise.CancellationError;var errorObj=util.errorObj;function PassThroughHandlerContext(promise,type,handler){this.promise=promise;this.type=type;this.handler=handler;this.called=false;this.cancelPromise=null;}PassThroughHandlerContext.prototype.isFinallyHandler=function(){return this.type===0;};function FinallyHandlerCancelReaction(finallyHandler){this.finallyHandler=finallyHandler;}FinallyHandlerCancelReaction.prototype._resultCancelled=function(){checkCancel(this.finallyHandler);};function checkCancel(ctx,reason){if(ctx.cancelPromise!=null){if(arguments.length>1){ctx.cancelPromise._reject(reason);}else {ctx.cancelPromise._cancel();}ctx.cancelPromise=null;return true;}return false;}function succeed(){return finallyHandler.call(this,this.promise._target()._settledValue());}function fail(reason){if(checkCancel(this,reason))return;errorObj.e=reason;return errorObj;}function finallyHandler(reasonOrValue){var promise=this.promise;var handler=this.handler;if(!this.called){this.called=true;var ret=this.isFinallyHandler()?handler.call(promise._boundValue()):handler.call(promise._boundValue(),reasonOrValue);if(ret!==undefined){promise._setReturnedNonUndefined();var maybePromise=tryConvertToPromise(ret,promise);if(maybePromise instanceof Promise){if(this.cancelPromise!=null){if(maybePromise.isCancelled()){var reason=new CancellationError("late cancellation observer");promise._attachExtraTrace(reason);errorObj.e=reason;return errorObj;}else if(maybePromise.isPending()){maybePromise._attachCancellationCallback(new FinallyHandlerCancelReaction(this));}}return maybePromise._then(succeed,fail,undefined,this,undefined);}}}if(promise.isRejected()){checkCancel(this);errorObj.e=reasonOrValue;return errorObj;}else {checkCancel(this);return reasonOrValue;}}Promise.prototype._passThrough=function(handler,type,success,fail){if(typeof handler!=="function")return this.then();return this._then(success,fail,undefined,new PassThroughHandlerContext(this,type,handler),undefined);};Promise.prototype.lastly=Promise.prototype["finally"]=function(handler){return this._passThrough(handler,0,finallyHandler,finallyHandler);};Promise.prototype.tap=function(handler){return this._passThrough(handler,1,finallyHandler);};return PassThroughHandlerContext;};},{"./util":36}],16:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,apiRejection,INTERNAL,tryConvertToPromise,Proxyable,debug){var errors=_dereq_("./errors");var TypeError=errors.TypeError;var util=_dereq_("./util");var errorObj=util.errorObj;var tryCatch=util.tryCatch;var yieldHandlers=[];function promiseFromYieldHandler(value,yieldHandlers,traceParent){for(var i=0;i<yieldHandlers.length;++i){traceParent._pushContext();var result=tryCatch(yieldHandlers[i])(value);traceParent._popContext();if(result===errorObj){traceParent._pushContext();var ret=Promise.reject(errorObj.e);traceParent._popContext();return ret;}var maybePromise=tryConvertToPromise(result,traceParent);if(maybePromise instanceof Promise)return maybePromise;}return null;}function PromiseSpawn(generatorFunction,receiver,yieldHandler,stack){if(debug.cancellation()){var internal=new Promise(INTERNAL);var _finallyPromise=this._finallyPromise=new Promise(INTERNAL);this._promise=internal.lastly(function(){return _finallyPromise;});internal._captureStackTrace();internal._setOnCancel(this);}else {var promise=this._promise=new Promise(INTERNAL);promise._captureStackTrace();}this._stack=stack;this._generatorFunction=generatorFunction;this._receiver=receiver;this._generator=undefined;this._yieldHandlers=typeof yieldHandler==="function"?[yieldHandler].concat(yieldHandlers):yieldHandlers;this._yieldedPromise=null;this._cancellationPhase=false;}util.inherits(PromiseSpawn,Proxyable);PromiseSpawn.prototype._isResolved=function(){return this._promise===null;};PromiseSpawn.prototype._cleanup=function(){this._promise=this._generator=null;if(debug.cancellation()&&this._finallyPromise!==null){this._finallyPromise._fulfill();this._finallyPromise=null;}};PromiseSpawn.prototype._promiseCancelled=function(){if(this._isResolved())return;var implementsReturn=typeof this._generator["return"]!=="undefined";var result;if(!implementsReturn){var reason=new Promise.CancellationError("generator .return() sentinel");Promise.coroutine.returnSentinel=reason;this._promise._attachExtraTrace(reason);this._promise._pushContext();result=tryCatch(this._generator["throw"]).call(this._generator,reason);this._promise._popContext();}else {this._promise._pushContext();result=tryCatch(this._generator["return"]).call(this._generator,undefined);this._promise._popContext();}this._cancellationPhase=true;this._yieldedPromise=null;this._continue(result);};PromiseSpawn.prototype._promiseFulfilled=function(value){this._yieldedPromise=null;this._promise._pushContext();var result=tryCatch(this._generator.next).call(this._generator,value);this._promise._popContext();this._continue(result);};PromiseSpawn.prototype._promiseRejected=function(reason){this._yieldedPromise=null;this._promise._attachExtraTrace(reason);this._promise._pushContext();var result=tryCatch(this._generator["throw"]).call(this._generator,reason);this._promise._popContext();this._continue(result);};PromiseSpawn.prototype._resultCancelled=function(){if(this._yieldedPromise instanceof Promise){var promise=this._yieldedPromise;this._yieldedPromise=null;promise.cancel();}};PromiseSpawn.prototype.promise=function(){return this._promise;};PromiseSpawn.prototype._run=function(){this._generator=this._generatorFunction.call(this._receiver);this._receiver=this._generatorFunction=undefined;this._promiseFulfilled(undefined);};PromiseSpawn.prototype._continue=function(result){var promise=this._promise;if(result===errorObj){this._cleanup();if(this._cancellationPhase){return promise.cancel();}else {return promise._rejectCallback(result.e,false);}}var value=result.value;if(result.done===true){this._cleanup();if(this._cancellationPhase){return promise.cancel();}else {return promise._resolveCallback(value);}}else {var maybePromise=tryConvertToPromise(value,this._promise);if(!(maybePromise instanceof Promise)){maybePromise=promiseFromYieldHandler(maybePromise,this._yieldHandlers,this._promise);if(maybePromise===null){this._promiseRejected(new TypeError("A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s",value)+"From coroutine:\n"+this._stack.split("\n").slice(1,-7).join("\n")));return;}}maybePromise=maybePromise._target();var bitField=maybePromise._bitField;;if((bitField&50397184)===0){this._yieldedPromise=maybePromise;maybePromise._proxy(this,null);}else if((bitField&33554432)!==0){this._promiseFulfilled(maybePromise._value());}else if((bitField&16777216)!==0){this._promiseRejected(maybePromise._reason());}else {this._promiseCancelled();}}};Promise.coroutine=function(generatorFunction,options){if(typeof generatorFunction!=="function"){throw new TypeError("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");}var yieldHandler=Object(options).yieldHandler;var PromiseSpawn$=PromiseSpawn;var stack=new Error().stack;return function(){var generator=generatorFunction.apply(this,arguments);var spawn=new PromiseSpawn$(undefined,undefined,yieldHandler,stack);var ret=spawn.promise();spawn._generator=generator;spawn._promiseFulfilled(undefined);return ret;};};Promise.coroutine.addYieldHandler=function(fn){if(typeof fn!=="function"){throw new TypeError("expecting a function but got "+util.classString(fn));}yieldHandlers.push(fn);};Promise.spawn=function(generatorFunction){debug.deprecated("Promise.spawn()","Promise.coroutine()");if(typeof generatorFunction!=="function"){return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");}var spawn=new PromiseSpawn(generatorFunction,this);var ret=spawn.promise();spawn._run(Promise.spawn);return ret;};};},{"./errors":12,"./util":36}],17:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,tryConvertToPromise,INTERNAL){var util=_dereq_("./util");var canEvaluate=util.canEvaluate;var tryCatch=util.tryCatch;var errorObj=util.errorObj;var reject;if(false){if(canEvaluate){var thenCallback=function thenCallback(i){return new Function("value","holder","                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g,i));};var promiseSetter=function promiseSetter(i){return new Function("promise","holder","                           \n\
	            'use strict';                                                    \n\
	            holder.pIndex = promise;                                         \n\
	            ".replace(/Index/g,i));};var generateHolderClass=function generateHolderClass(total){var props=new Array(total);for(var i=0;i<props.length;++i){props[i]="this.p"+(i+1);}var assignment=props.join(" = ")+" = null;";var cancellationCode="var promise;\n"+props.map(function(prop){return "                                                         \n\
	                promise = "+prop+";                                      \n\
	                if (promise instanceof Promise) {                            \n\
	                    promise.cancel();                                        \n\
	                }                                                            \n\
	            ";}).join("\n");var passedArguments=props.join(", ");var name="Holder$"+total;var code="return function(tryCatch, errorObj, Promise) {           \n\
	            'use strict';                                                    \n\
	            function [TheName](fn) {                                         \n\
	                [TheProperties]                                              \n\
	                this.fn = fn;                                                \n\
	                this.now = 0;                                                \n\
	            }                                                                \n\
	            [TheName].prototype.checkFulfillment = function(promise) {       \n\
	                var now = ++this.now;                                        \n\
	                if (now === [TheTotal]) {                                    \n\
	                    promise._pushContext();                                  \n\
	                    var callback = this.fn;                                  \n\
	                    var ret = tryCatch(callback)([ThePassedArguments]);      \n\
	                    promise._popContext();                                   \n\
	                    if (ret === errorObj) {                                  \n\
	                        promise._rejectCallback(ret.e, false);               \n\
	                    } else {                                                 \n\
	                        promise._resolveCallback(ret);                       \n\
	                    }                                                        \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype._resultCancelled = function() {              \n\
	                [CancellationCode]                                           \n\
	            };                                                               \n\
	                                                                             \n\
	            return [TheName];                                                \n\
	        }(tryCatch, errorObj, Promise);                                      \n\
	        ";code=code.replace(/\[TheName\]/g,name).replace(/\[TheTotal\]/g,total).replace(/\[ThePassedArguments\]/g,passedArguments).replace(/\[TheProperties\]/g,assignment).replace(/\[CancellationCode\]/g,cancellationCode);return new Function("tryCatch","errorObj","Promise",code)(tryCatch,errorObj,Promise);};var holderClasses=[];var thenCallbacks=[];var promiseSetters=[];for(var i=0;i<8;++i){holderClasses.push(generateHolderClass(i+1));thenCallbacks.push(thenCallback(i+1));promiseSetters.push(promiseSetter(i+1));}reject=function reject(reason){this._reject(reason);};}}Promise.join=function(){var last=arguments.length-1;var fn;if(last>0&&typeof arguments[last]==="function"){fn=arguments[last];if(false){if(last<=8&&canEvaluate){var ret=new Promise(INTERNAL);ret._captureStackTrace();var HolderClass=holderClasses[last-1];var holder=new HolderClass(fn);var callbacks=thenCallbacks;for(var i=0;i<last;++i){var maybePromise=tryConvertToPromise(arguments[i],ret);if(maybePromise instanceof Promise){maybePromise=maybePromise._target();var bitField=maybePromise._bitField;;if((bitField&50397184)===0){maybePromise._then(callbacks[i],reject,undefined,ret,holder);promiseSetters[i](maybePromise,holder);}else if((bitField&33554432)!==0){callbacks[i].call(ret,maybePromise._value(),holder);}else if((bitField&16777216)!==0){ret._reject(maybePromise._reason());}else {ret._cancel();}}else {callbacks[i].call(ret,maybePromise,holder);}}if(!ret._isFateSealed()){ret._setAsyncGuaranteed();ret._setOnCancel(holder);}return ret;}}}var args=[].slice.call(arguments);;if(fn)args.pop();var ret=new PromiseArray(args).promise();return fn!==undefined?ret.spread(fn):ret;};};},{"./util":36}],18:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,apiRejection,tryConvertToPromise,INTERNAL,debug){var getDomain=Promise._getDomain;var util=_dereq_("./util");var tryCatch=util.tryCatch;var errorObj=util.errorObj;var EMPTY_ARRAY=[];function MappingPromiseArray(promises,fn,limit,_filter){this.constructor$(promises);this._promise._captureStackTrace();var domain=getDomain();this._callback=domain===null?fn:domain.bind(fn);this._preservedValues=_filter===INTERNAL?new Array(this.length()):null;this._limit=limit;this._inFlight=0;this._queue=limit>=1?[]:EMPTY_ARRAY;this._init$(undefined,-2);}util.inherits(MappingPromiseArray,PromiseArray);MappingPromiseArray.prototype._init=function(){};MappingPromiseArray.prototype._promiseFulfilled=function(value,index){var values=this._values;var length=this.length();var preservedValues=this._preservedValues;var limit=this._limit;if(index<0){index=index*-1-1;values[index]=value;if(limit>=1){this._inFlight--;this._drainQueue();if(this._isResolved())return true;}}else {if(limit>=1&&this._inFlight>=limit){values[index]=value;this._queue.push(index);return false;}if(preservedValues!==null)preservedValues[index]=value;var promise=this._promise;var callback=this._callback;var receiver=promise._boundValue();promise._pushContext();var ret=tryCatch(callback).call(receiver,value,index,length);var promiseCreated=promise._popContext();debug.checkForgottenReturns(ret,promiseCreated,preservedValues!==null?"Promise.filter":"Promise.map",promise);if(ret===errorObj){this._reject(ret.e);return true;}var maybePromise=tryConvertToPromise(ret,this._promise);if(maybePromise instanceof Promise){maybePromise=maybePromise._target();var bitField=maybePromise._bitField;;if((bitField&50397184)===0){if(limit>=1)this._inFlight++;values[index]=maybePromise;maybePromise._proxy(this,(index+1)*-1);return false;}else if((bitField&33554432)!==0){ret=maybePromise._value();}else if((bitField&16777216)!==0){this._reject(maybePromise._reason());return true;}else {this._cancel();return true;}}values[index]=ret;}var totalResolved=++this._totalResolved;if(totalResolved>=length){if(preservedValues!==null){this._filter(values,preservedValues);}else {this._resolve(values);}return true;}return false;};MappingPromiseArray.prototype._drainQueue=function(){var queue=this._queue;var limit=this._limit;var values=this._values;while(queue.length>0&&this._inFlight<limit){if(this._isResolved())return;var index=queue.pop();this._promiseFulfilled(values[index],index);}};MappingPromiseArray.prototype._filter=function(booleans,values){var len=values.length;var ret=new Array(len);var j=0;for(var i=0;i<len;++i){if(booleans[i])ret[j++]=values[i];}ret.length=j;this._resolve(ret);};MappingPromiseArray.prototype.preservedValues=function(){return this._preservedValues;};function map(promises,fn,options,_filter){if(typeof fn!=="function"){return apiRejection("expecting a function but got "+util.classString(fn));}var limit=0;if(options!==undefined){if((typeof options==="undefined"?"undefined":_typeof(options))==="object"&&options!==null){if(typeof options.concurrency!=="number"){return Promise.reject(new TypeError("'concurrency' must be a number but it is "+util.classString(options.concurrency)));}limit=options.concurrency;}else {return Promise.reject(new TypeError("options argument must be an object but it is "+util.classString(options)));}}limit=typeof limit==="number"&&isFinite(limit)&&limit>=1?limit:0;return new MappingPromiseArray(promises,fn,limit,_filter).promise();}Promise.prototype.map=function(fn,options){return map(this,fn,options,null);};Promise.map=function(promises,fn,options,_filter){return map(promises,fn,options,_filter);};};},{"./util":36}],19:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL,tryConvertToPromise,apiRejection,debug){var util=_dereq_("./util");var tryCatch=util.tryCatch;Promise.method=function(fn){if(typeof fn!=="function"){throw new Promise.TypeError("expecting a function but got "+util.classString(fn));}return function(){var ret=new Promise(INTERNAL);ret._captureStackTrace();ret._pushContext();var value=tryCatch(fn).apply(this,arguments);var promiseCreated=ret._popContext();debug.checkForgottenReturns(value,promiseCreated,"Promise.method",ret);ret._resolveFromSyncValue(value);return ret;};};Promise.attempt=Promise["try"]=function(fn){if(typeof fn!=="function"){return apiRejection("expecting a function but got "+util.classString(fn));}var ret=new Promise(INTERNAL);ret._captureStackTrace();ret._pushContext();var value;if(arguments.length>1){debug.deprecated("calling Promise.try with more than 1 argument");var arg=arguments[1];var ctx=arguments[2];value=util.isArray(arg)?tryCatch(fn).apply(ctx,arg):tryCatch(fn).call(ctx,arg);}else {value=tryCatch(fn)();}var promiseCreated=ret._popContext();debug.checkForgottenReturns(value,promiseCreated,"Promise.try",ret);ret._resolveFromSyncValue(value);return ret;};Promise.prototype._resolveFromSyncValue=function(value){if(value===util.errorObj){this._rejectCallback(value.e,false);}else {this._resolveCallback(value,true);}};};},{"./util":36}],20:[function(_dereq_,module,exports){"use strict";var util=_dereq_("./util");var maybeWrapAsError=util.maybeWrapAsError;var errors=_dereq_("./errors");var OperationalError=errors.OperationalError;var es5=_dereq_("./es5");function isUntypedError(obj){return obj instanceof Error&&es5.getPrototypeOf(obj)===Error.prototype;}var rErrorKey=/^(?:name|message|stack|cause)$/;function wrapAsOperationalError(obj){var ret;if(isUntypedError(obj)){ret=new OperationalError(obj);ret.name=obj.name;ret.message=obj.message;ret.stack=obj.stack;var keys=es5.keys(obj);for(var i=0;i<keys.length;++i){var key=keys[i];if(!rErrorKey.test(key)){ret[key]=obj[key];}}return ret;}util.markAsOriginatingFromRejection(obj);return obj;}function nodebackForPromise(promise,multiArgs){return function(err,value){if(promise===null)return;if(err){var wrapped=wrapAsOperationalError(maybeWrapAsError(err));promise._attachExtraTrace(wrapped);promise._reject(wrapped);}else if(!multiArgs){promise._fulfill(value);}else {var args=[].slice.call(arguments,1);;promise._fulfill(args);}promise=null;};}module.exports=nodebackForPromise;},{"./errors":12,"./es5":13,"./util":36}],21:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise){var util=_dereq_("./util");var async=Promise._async;var tryCatch=util.tryCatch;var errorObj=util.errorObj;function spreadAdapter(val,nodeback){var promise=this;if(!util.isArray(val))return successAdapter.call(promise,val,nodeback);var ret=tryCatch(nodeback).apply(promise._boundValue(),[null].concat(val));if(ret===errorObj){async.throwLater(ret.e);}}function successAdapter(val,nodeback){var promise=this;var receiver=promise._boundValue();var ret=val===undefined?tryCatch(nodeback).call(receiver,null):tryCatch(nodeback).call(receiver,null,val);if(ret===errorObj){async.throwLater(ret.e);}}function errorAdapter(reason,nodeback){var promise=this;if(!reason){var newReason=new Error(reason+"");newReason.cause=reason;reason=newReason;}var ret=tryCatch(nodeback).call(promise._boundValue(),reason);if(ret===errorObj){async.throwLater(ret.e);}}Promise.prototype.asCallback=Promise.prototype.nodeify=function(nodeback,options){if(typeof nodeback=="function"){var adapter=successAdapter;if(options!==undefined&&Object(options).spread){adapter=spreadAdapter;}this._then(adapter,errorAdapter,undefined,this,nodeback);}return this;};};},{"./util":36}],22:[function(_dereq_,module,exports){"use strict";module.exports=function(){var makeSelfResolutionError=function makeSelfResolutionError(){return new TypeError("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");};var reflectHandler=function reflectHandler(){return new Promise.PromiseInspection(this._target());};var apiRejection=function apiRejection(msg){return Promise.reject(new TypeError(msg));};function Proxyable(){}var UNDEFINED_BINDING={};var util=_dereq_("./util");var getDomain;if(util.isNode){getDomain=function getDomain(){var ret=process.domain;if(ret===undefined)ret=null;return ret;};}else {getDomain=function getDomain(){return null;};}util.notEnumerableProp(Promise,"_getDomain",getDomain);var es5=_dereq_("./es5");var Async=_dereq_("./async");var async=new Async();es5.defineProperty(Promise,"_async",{value:async});var errors=_dereq_("./errors");var TypeError=Promise.TypeError=errors.TypeError;Promise.RangeError=errors.RangeError;var CancellationError=Promise.CancellationError=errors.CancellationError;Promise.TimeoutError=errors.TimeoutError;Promise.OperationalError=errors.OperationalError;Promise.RejectionError=errors.OperationalError;Promise.AggregateError=errors.AggregateError;var INTERNAL=function INTERNAL(){};var APPLY={};var NEXT_FILTER={};var tryConvertToPromise=_dereq_("./thenables")(Promise,INTERNAL);var PromiseArray=_dereq_("./promise_array")(Promise,INTERNAL,tryConvertToPromise,apiRejection,Proxyable);var Context=_dereq_("./context")(Promise); /*jshint unused:false*/var createContext=Context.create;var debug=_dereq_("./debuggability")(Promise,Context);var CapturedTrace=debug.CapturedTrace;var PassThroughHandlerContext=_dereq_("./finally")(Promise,tryConvertToPromise);var catchFilter=_dereq_("./catch_filter")(NEXT_FILTER);var nodebackForPromise=_dereq_("./nodeback");var errorObj=util.errorObj;var tryCatch=util.tryCatch;function check(self,executor){if(typeof executor!=="function"){throw new TypeError("expecting a function but got "+util.classString(executor));}if(self.constructor!==Promise){throw new TypeError("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");}}function Promise(executor){this._bitField=0;this._fulfillmentHandler0=undefined;this._rejectionHandler0=undefined;this._promise0=undefined;this._receiver0=undefined;if(executor!==INTERNAL){check(this,executor);this._resolveFromExecutor(executor);}this._promiseCreated();this._fireEvent("promiseCreated",this);}Promise.prototype.toString=function(){return "[object Promise]";};Promise.prototype.caught=Promise.prototype["catch"]=function(fn){var len=arguments.length;if(len>1){var catchInstances=new Array(len-1),j=0,i;for(i=0;i<len-1;++i){var item=arguments[i];if(util.isObject(item)){catchInstances[j++]=item;}else {return apiRejection("expecting an object but got "+util.classString(item));}}catchInstances.length=j;fn=arguments[i];return this.then(undefined,catchFilter(catchInstances,fn,this));}return this.then(undefined,fn);};Promise.prototype.reflect=function(){return this._then(reflectHandler,reflectHandler,undefined,this,undefined);};Promise.prototype.then=function(didFulfill,didReject){if(debug.warnings()&&arguments.length>0&&typeof didFulfill!=="function"&&typeof didReject!=="function"){var msg=".then() only accepts functions but was passed: "+util.classString(didFulfill);if(arguments.length>1){msg+=", "+util.classString(didReject);}this._warn(msg);}return this._then(didFulfill,didReject,undefined,undefined,undefined);};Promise.prototype.done=function(didFulfill,didReject){var promise=this._then(didFulfill,didReject,undefined,undefined,undefined);promise._setIsFinal();};Promise.prototype.spread=function(fn){if(typeof fn!=="function"){return apiRejection("expecting a function but got "+util.classString(fn));}return this.all()._then(fn,undefined,undefined,APPLY,undefined);};Promise.prototype.toJSON=function(){var ret={isFulfilled:false,isRejected:false,fulfillmentValue:undefined,rejectionReason:undefined};if(this.isFulfilled()){ret.fulfillmentValue=this.value();ret.isFulfilled=true;}else if(this.isRejected()){ret.rejectionReason=this.reason();ret.isRejected=true;}return ret;};Promise.prototype.all=function(){if(arguments.length>0){this._warn(".all() was passed arguments but it does not take any");}return new PromiseArray(this).promise();};Promise.prototype.error=function(fn){return this.caught(util.originatesFromRejection,fn);};Promise.getNewLibraryCopy=module.exports;Promise.is=function(val){return val instanceof Promise;};Promise.fromNode=Promise.fromCallback=function(fn){var ret=new Promise(INTERNAL);ret._captureStackTrace();var multiArgs=arguments.length>1?!!Object(arguments[1]).multiArgs:false;var result=tryCatch(fn)(nodebackForPromise(ret,multiArgs));if(result===errorObj){ret._rejectCallback(result.e,true);}if(!ret._isFateSealed())ret._setAsyncGuaranteed();return ret;};Promise.all=function(promises){return new PromiseArray(promises).promise();};Promise.cast=function(obj){var ret=tryConvertToPromise(obj);if(!(ret instanceof Promise)){ret=new Promise(INTERNAL);ret._captureStackTrace();ret._setFulfilled();ret._rejectionHandler0=obj;}return ret;};Promise.resolve=Promise.fulfilled=Promise.cast;Promise.reject=Promise.rejected=function(reason){var ret=new Promise(INTERNAL);ret._captureStackTrace();ret._rejectCallback(reason,true);return ret;};Promise.setScheduler=function(fn){if(typeof fn!=="function"){throw new TypeError("expecting a function but got "+util.classString(fn));}return async.setScheduler(fn);};Promise.prototype._then=function(didFulfill,didReject,_,receiver,internalData){var haveInternalData=internalData!==undefined;var promise=haveInternalData?internalData:new Promise(INTERNAL);var target=this._target();var bitField=target._bitField;if(!haveInternalData){promise._propagateFrom(this,3);promise._captureStackTrace();if(receiver===undefined&&(this._bitField&2097152)!==0){if(!((bitField&50397184)===0)){receiver=this._boundValue();}else {receiver=target===this?undefined:this._boundTo;}}this._fireEvent("promiseChained",this,promise);}var domain=getDomain();if(!((bitField&50397184)===0)){var handler,value,settler=target._settlePromiseCtx;if((bitField&33554432)!==0){value=target._rejectionHandler0;handler=didFulfill;}else if((bitField&16777216)!==0){value=target._fulfillmentHandler0;handler=didReject;target._unsetRejectionIsUnhandled();}else {settler=target._settlePromiseLateCancellationObserver;value=new CancellationError("late cancellation observer");target._attachExtraTrace(value);handler=didReject;}async.invoke(settler,target,{handler:domain===null?handler:typeof handler==="function"&&domain.bind(handler),promise:promise,receiver:receiver,value:value});}else {target._addCallbacks(didFulfill,didReject,promise,receiver,domain);}return promise;};Promise.prototype._length=function(){return this._bitField&65535;};Promise.prototype._isFateSealed=function(){return (this._bitField&117506048)!==0;};Promise.prototype._isFollowing=function(){return (this._bitField&67108864)===67108864;};Promise.prototype._setLength=function(len){this._bitField=this._bitField&-65536|len&65535;};Promise.prototype._setFulfilled=function(){this._bitField=this._bitField|33554432;this._fireEvent("promiseFulfilled",this);};Promise.prototype._setRejected=function(){this._bitField=this._bitField|16777216;this._fireEvent("promiseRejected",this);};Promise.prototype._setFollowing=function(){this._bitField=this._bitField|67108864;this._fireEvent("promiseResolved",this);};Promise.prototype._setIsFinal=function(){this._bitField=this._bitField|4194304;};Promise.prototype._isFinal=function(){return (this._bitField&4194304)>0;};Promise.prototype._unsetCancelled=function(){this._bitField=this._bitField&~65536;};Promise.prototype._setCancelled=function(){this._bitField=this._bitField|65536;this._fireEvent("promiseCancelled",this);};Promise.prototype._setAsyncGuaranteed=function(){if(async.hasCustomScheduler())return;this._bitField=this._bitField|134217728;};Promise.prototype._receiverAt=function(index){var ret=index===0?this._receiver0:this[index*4-4+3];if(ret===UNDEFINED_BINDING){return undefined;}else if(ret===undefined&&this._isBound()){return this._boundValue();}return ret;};Promise.prototype._promiseAt=function(index){return this[index*4-4+2];};Promise.prototype._fulfillmentHandlerAt=function(index){return this[index*4-4+0];};Promise.prototype._rejectionHandlerAt=function(index){return this[index*4-4+1];};Promise.prototype._boundValue=function(){};Promise.prototype._migrateCallback0=function(follower){var bitField=follower._bitField;var fulfill=follower._fulfillmentHandler0;var reject=follower._rejectionHandler0;var promise=follower._promise0;var receiver=follower._receiverAt(0);if(receiver===undefined)receiver=UNDEFINED_BINDING;this._addCallbacks(fulfill,reject,promise,receiver,null);};Promise.prototype._migrateCallbackAt=function(follower,index){var fulfill=follower._fulfillmentHandlerAt(index);var reject=follower._rejectionHandlerAt(index);var promise=follower._promiseAt(index);var receiver=follower._receiverAt(index);if(receiver===undefined)receiver=UNDEFINED_BINDING;this._addCallbacks(fulfill,reject,promise,receiver,null);};Promise.prototype._addCallbacks=function(fulfill,reject,promise,receiver,domain){var index=this._length();if(index>=65535-4){index=0;this._setLength(0);}if(index===0){this._promise0=promise;this._receiver0=receiver;if(typeof fulfill==="function"){this._fulfillmentHandler0=domain===null?fulfill:domain.bind(fulfill);}if(typeof reject==="function"){this._rejectionHandler0=domain===null?reject:domain.bind(reject);}}else {var base=index*4-4;this[base+2]=promise;this[base+3]=receiver;if(typeof fulfill==="function"){this[base+0]=domain===null?fulfill:domain.bind(fulfill);}if(typeof reject==="function"){this[base+1]=domain===null?reject:domain.bind(reject);}}this._setLength(index+1);return index;};Promise.prototype._proxy=function(proxyable,arg){this._addCallbacks(undefined,undefined,arg,proxyable,null);};Promise.prototype._resolveCallback=function(value,shouldBind){if((this._bitField&117506048)!==0)return;if(value===this)return this._rejectCallback(makeSelfResolutionError(),false);var maybePromise=tryConvertToPromise(value,this);if(!(maybePromise instanceof Promise))return this._fulfill(value);if(shouldBind)this._propagateFrom(maybePromise,2);var promise=maybePromise._target();if(promise===this){this._reject(makeSelfResolutionError());return;}var bitField=promise._bitField;if((bitField&50397184)===0){var len=this._length();if(len>0)promise._migrateCallback0(this);for(var i=1;i<len;++i){promise._migrateCallbackAt(this,i);}this._setFollowing();this._setLength(0);this._setFollowee(promise);}else if((bitField&33554432)!==0){this._fulfill(promise._value());}else if((bitField&16777216)!==0){this._reject(promise._reason());}else {var reason=new CancellationError("late cancellation observer");promise._attachExtraTrace(reason);this._reject(reason);}};Promise.prototype._rejectCallback=function(reason,synchronous,ignoreNonErrorWarnings){var trace=util.ensureErrorObject(reason);var hasStack=trace===reason;if(!hasStack&&!ignoreNonErrorWarnings&&debug.warnings()){var message="a promise was rejected with a non-error: "+util.classString(reason);this._warn(message,true);}this._attachExtraTrace(trace,synchronous?hasStack:false);this._reject(reason);};Promise.prototype._resolveFromExecutor=function(executor){var promise=this;this._captureStackTrace();this._pushContext();var synchronous=true;var r=this._execute(executor,function(value){promise._resolveCallback(value);},function(reason){promise._rejectCallback(reason,synchronous);});synchronous=false;this._popContext();if(r!==undefined){promise._rejectCallback(r,true);}};Promise.prototype._settlePromiseFromHandler=function(handler,receiver,value,promise){var bitField=promise._bitField;if((bitField&65536)!==0)return;promise._pushContext();var x;if(receiver===APPLY){if(!value||typeof value.length!=="number"){x=errorObj;x.e=new TypeError("cannot .spread() a non-array: "+util.classString(value));}else {x=tryCatch(handler).apply(this._boundValue(),value);}}else {x=tryCatch(handler).call(receiver,value);}var promiseCreated=promise._popContext();bitField=promise._bitField;if((bitField&65536)!==0)return;if(x===NEXT_FILTER){promise._reject(value);}else if(x===errorObj){promise._rejectCallback(x.e,false);}else {debug.checkForgottenReturns(x,promiseCreated,"",promise,this);promise._resolveCallback(x);}};Promise.prototype._target=function(){var ret=this;while(ret._isFollowing()){ret=ret._followee();}return ret;};Promise.prototype._followee=function(){return this._rejectionHandler0;};Promise.prototype._setFollowee=function(promise){this._rejectionHandler0=promise;};Promise.prototype._settlePromise=function(promise,handler,receiver,value){var isPromise=promise instanceof Promise;var bitField=this._bitField;var asyncGuaranteed=(bitField&134217728)!==0;if((bitField&65536)!==0){if(isPromise)promise._invokeInternalOnCancel();if(receiver instanceof PassThroughHandlerContext&&receiver.isFinallyHandler()){receiver.cancelPromise=promise;if(tryCatch(handler).call(receiver,value)===errorObj){promise._reject(errorObj.e);}}else if(handler===reflectHandler){promise._fulfill(reflectHandler.call(receiver));}else if(receiver instanceof Proxyable){receiver._promiseCancelled(promise);}else if(isPromise||promise instanceof PromiseArray){promise._cancel();}else {receiver.cancel();}}else if(typeof handler==="function"){if(!isPromise){handler.call(receiver,value,promise);}else {if(asyncGuaranteed)promise._setAsyncGuaranteed();this._settlePromiseFromHandler(handler,receiver,value,promise);}}else if(receiver instanceof Proxyable){if(!receiver._isResolved()){if((bitField&33554432)!==0){receiver._promiseFulfilled(value,promise);}else {receiver._promiseRejected(value,promise);}}}else if(isPromise){if(asyncGuaranteed)promise._setAsyncGuaranteed();if((bitField&33554432)!==0){promise._fulfill(value);}else {promise._reject(value);}}};Promise.prototype._settlePromiseLateCancellationObserver=function(ctx){var handler=ctx.handler;var promise=ctx.promise;var receiver=ctx.receiver;var value=ctx.value;if(typeof handler==="function"){if(!(promise instanceof Promise)){handler.call(receiver,value,promise);}else {this._settlePromiseFromHandler(handler,receiver,value,promise);}}else if(promise instanceof Promise){promise._reject(value);}};Promise.prototype._settlePromiseCtx=function(ctx){this._settlePromise(ctx.promise,ctx.handler,ctx.receiver,ctx.value);};Promise.prototype._settlePromise0=function(handler,value,bitField){var promise=this._promise0;var receiver=this._receiverAt(0);this._promise0=undefined;this._receiver0=undefined;this._settlePromise(promise,handler,receiver,value);};Promise.prototype._clearCallbackDataAtIndex=function(index){var base=index*4-4;this[base+2]=this[base+3]=this[base+0]=this[base+1]=undefined;};Promise.prototype._fulfill=function(value){var bitField=this._bitField;if((bitField&117506048)>>>16)return;if(value===this){var err=makeSelfResolutionError();this._attachExtraTrace(err);return this._reject(err);}this._setFulfilled();this._rejectionHandler0=value;if((bitField&65535)>0){if((bitField&134217728)!==0){this._settlePromises();}else {async.settlePromises(this);}}};Promise.prototype._reject=function(reason){var bitField=this._bitField;if((bitField&117506048)>>>16)return;this._setRejected();this._fulfillmentHandler0=reason;if(this._isFinal()){return async.fatalError(reason,util.isNode);}if((bitField&65535)>0){async.settlePromises(this);}else {this._ensurePossibleRejectionHandled();}};Promise.prototype._fulfillPromises=function(len,value){for(var i=1;i<len;i++){var handler=this._fulfillmentHandlerAt(i);var promise=this._promiseAt(i);var receiver=this._receiverAt(i);this._clearCallbackDataAtIndex(i);this._settlePromise(promise,handler,receiver,value);}};Promise.prototype._rejectPromises=function(len,reason){for(var i=1;i<len;i++){var handler=this._rejectionHandlerAt(i);var promise=this._promiseAt(i);var receiver=this._receiverAt(i);this._clearCallbackDataAtIndex(i);this._settlePromise(promise,handler,receiver,reason);}};Promise.prototype._settlePromises=function(){var bitField=this._bitField;var len=bitField&65535;if(len>0){if((bitField&16842752)!==0){var reason=this._fulfillmentHandler0;this._settlePromise0(this._rejectionHandler0,reason,bitField);this._rejectPromises(len,reason);}else {var value=this._rejectionHandler0;this._settlePromise0(this._fulfillmentHandler0,value,bitField);this._fulfillPromises(len,value);}this._setLength(0);}this._clearCancellationData();};Promise.prototype._settledValue=function(){var bitField=this._bitField;if((bitField&33554432)!==0){return this._rejectionHandler0;}else if((bitField&16777216)!==0){return this._fulfillmentHandler0;}};function deferResolve(v){this.promise._resolveCallback(v);}function deferReject(v){this.promise._rejectCallback(v,false);}Promise.defer=Promise.pending=function(){debug.deprecated("Promise.defer","new Promise");var promise=new Promise(INTERNAL);return {promise:promise,resolve:deferResolve,reject:deferReject};};util.notEnumerableProp(Promise,"_makeSelfResolutionError",makeSelfResolutionError);_dereq_("./method")(Promise,INTERNAL,tryConvertToPromise,apiRejection,debug);_dereq_("./bind")(Promise,INTERNAL,tryConvertToPromise,debug);_dereq_("./cancel")(Promise,PromiseArray,apiRejection,debug);_dereq_("./direct_resolve")(Promise);_dereq_("./synchronous_inspection")(Promise);_dereq_("./join")(Promise,PromiseArray,tryConvertToPromise,INTERNAL,debug);Promise.Promise=Promise;Promise.version="3.4.0";_dereq_('./map.js')(Promise,PromiseArray,apiRejection,tryConvertToPromise,INTERNAL,debug);_dereq_('./call_get.js')(Promise);_dereq_('./using.js')(Promise,apiRejection,tryConvertToPromise,createContext,INTERNAL,debug);_dereq_('./timers.js')(Promise,INTERNAL,debug);_dereq_('./generators.js')(Promise,apiRejection,INTERNAL,tryConvertToPromise,Proxyable,debug);_dereq_('./nodeify.js')(Promise);_dereq_('./promisify.js')(Promise,INTERNAL);_dereq_('./props.js')(Promise,PromiseArray,tryConvertToPromise,apiRejection);_dereq_('./race.js')(Promise,INTERNAL,tryConvertToPromise,apiRejection);_dereq_('./reduce.js')(Promise,PromiseArray,apiRejection,tryConvertToPromise,INTERNAL,debug);_dereq_('./settle.js')(Promise,PromiseArray,debug);_dereq_('./some.js')(Promise,PromiseArray,apiRejection);_dereq_('./filter.js')(Promise,INTERNAL);_dereq_('./each.js')(Promise,INTERNAL);_dereq_('./any.js')(Promise);util.toFastProperties(Promise);util.toFastProperties(Promise.prototype);function fillTypes(value){var p=new Promise(INTERNAL);p._fulfillmentHandler0=value;p._rejectionHandler0=value;p._promise0=value;p._receiver0=value;} // Complete slack tracking, opt out of field-type tracking and
	// stabilize map
	fillTypes({a:1});fillTypes({b:2});fillTypes({c:3});fillTypes(1);fillTypes(function(){});fillTypes(undefined);fillTypes(false);fillTypes(new Promise(INTERNAL));debug.setBounds(Async.firstLineError,util.lastLineError);return Promise;};},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL,tryConvertToPromise,apiRejection,Proxyable){var util=_dereq_("./util");var isArray=util.isArray;function toResolutionValue(val){switch(val){case -2:return [];case -3:return {};}}function PromiseArray(values){var promise=this._promise=new Promise(INTERNAL);if(values instanceof Promise){promise._propagateFrom(values,3);}promise._setOnCancel(this);this._values=values;this._length=0;this._totalResolved=0;this._init(undefined,-2);}util.inherits(PromiseArray,Proxyable);PromiseArray.prototype.length=function(){return this._length;};PromiseArray.prototype.promise=function(){return this._promise;};PromiseArray.prototype._init=function init(_,resolveValueIfEmpty){var values=tryConvertToPromise(this._values,this._promise);if(values instanceof Promise){values=values._target();var bitField=values._bitField;;this._values=values;if((bitField&50397184)===0){this._promise._setAsyncGuaranteed();return values._then(init,this._reject,undefined,this,resolveValueIfEmpty);}else if((bitField&33554432)!==0){values=values._value();}else if((bitField&16777216)!==0){return this._reject(values._reason());}else {return this._cancel();}}values=util.asArray(values);if(values===null){var err=apiRejection("expecting an array or an iterable object but got "+util.classString(values)).reason();this._promise._rejectCallback(err,false);return;}if(values.length===0){if(resolveValueIfEmpty===-5){this._resolveEmptyArray();}else {this._resolve(toResolutionValue(resolveValueIfEmpty));}return;}this._iterate(values);};PromiseArray.prototype._iterate=function(values){var len=this.getActualLength(values.length);this._length=len;this._values=this.shouldCopyValues()?new Array(len):this._values;var result=this._promise;var isResolved=false;var bitField=null;for(var i=0;i<len;++i){var maybePromise=tryConvertToPromise(values[i],result);if(maybePromise instanceof Promise){maybePromise=maybePromise._target();bitField=maybePromise._bitField;}else {bitField=null;}if(isResolved){if(bitField!==null){maybePromise.suppressUnhandledRejections();}}else if(bitField!==null){if((bitField&50397184)===0){maybePromise._proxy(this,i);this._values[i]=maybePromise;}else if((bitField&33554432)!==0){isResolved=this._promiseFulfilled(maybePromise._value(),i);}else if((bitField&16777216)!==0){isResolved=this._promiseRejected(maybePromise._reason(),i);}else {isResolved=this._promiseCancelled(i);}}else {isResolved=this._promiseFulfilled(maybePromise,i);}}if(!isResolved)result._setAsyncGuaranteed();};PromiseArray.prototype._isResolved=function(){return this._values===null;};PromiseArray.prototype._resolve=function(value){this._values=null;this._promise._fulfill(value);};PromiseArray.prototype._cancel=function(){if(this._isResolved()||!this._promise.isCancellable())return;this._values=null;this._promise._cancel();};PromiseArray.prototype._reject=function(reason){this._values=null;this._promise._rejectCallback(reason,false);};PromiseArray.prototype._promiseFulfilled=function(value,index){this._values[index]=value;var totalResolved=++this._totalResolved;if(totalResolved>=this._length){this._resolve(this._values);return true;}return false;};PromiseArray.prototype._promiseCancelled=function(){this._cancel();return true;};PromiseArray.prototype._promiseRejected=function(reason){this._totalResolved++;this._reject(reason);return true;};PromiseArray.prototype._resultCancelled=function(){if(this._isResolved())return;var values=this._values;this._cancel();if(values instanceof Promise){values.cancel();}else {for(var i=0;i<values.length;++i){if(values[i] instanceof Promise){values[i].cancel();}}}};PromiseArray.prototype.shouldCopyValues=function(){return true;};PromiseArray.prototype.getActualLength=function(len){return len;};return PromiseArray;};},{"./util":36}],24:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL){var THIS={};var util=_dereq_("./util");var nodebackForPromise=_dereq_("./nodeback");var withAppended=util.withAppended;var maybeWrapAsError=util.maybeWrapAsError;var canEvaluate=util.canEvaluate;var TypeError=_dereq_("./errors").TypeError;var defaultSuffix="Async";var defaultPromisified={__isPromisified__:true};var noCopyProps=["arity","length","name","arguments","caller","callee","prototype","__isPromisified__"];var noCopyPropsPattern=new RegExp("^(?:"+noCopyProps.join("|")+")$");var defaultFilter=function defaultFilter(name){return util.isIdentifier(name)&&name.charAt(0)!=="_"&&name!=="constructor";};function propsFilter(key){return !noCopyPropsPattern.test(key);}function isPromisified(fn){try{return fn.__isPromisified__===true;}catch(e){return false;}}function hasPromisified(obj,key,suffix){var val=util.getDataPropertyOrDefault(obj,key+suffix,defaultPromisified);return val?isPromisified(val):false;}function checkValid(ret,suffix,suffixRegexp){for(var i=0;i<ret.length;i+=2){var key=ret[i];if(suffixRegexp.test(key)){var keyWithoutAsyncSuffix=key.replace(suffixRegexp,"");for(var j=0;j<ret.length;j+=2){if(ret[j]===keyWithoutAsyncSuffix){throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s",suffix));}}}}}function promisifiableMethods(obj,suffix,suffixRegexp,filter){var keys=util.inheritedDataKeys(obj);var ret=[];for(var i=0;i<keys.length;++i){var key=keys[i];var value=obj[key];var passesDefaultFilter=filter===defaultFilter?true:defaultFilter(key,value,obj);if(typeof value==="function"&&!isPromisified(value)&&!hasPromisified(obj,key,suffix)&&filter(key,value,obj,passesDefaultFilter)){ret.push(key,value);}}checkValid(ret,suffix,suffixRegexp);return ret;}var escapeIdentRegex=function escapeIdentRegex(str){return str.replace(/([$])/,"\\$");};var makeNodePromisifiedEval;if(false){var switchCaseArgumentOrder=function switchCaseArgumentOrder(likelyArgumentCount){var ret=[likelyArgumentCount];var min=Math.max(0,likelyArgumentCount-1-3);for(var i=likelyArgumentCount-1;i>=min;--i){ret.push(i);}for(var i=likelyArgumentCount+1;i<=3;++i){ret.push(i);}return ret;};var argumentSequence=function argumentSequence(argumentCount){return util.filledRange(argumentCount,"_arg","");};var parameterDeclaration=function parameterDeclaration(parameterCount){return util.filledRange(Math.max(parameterCount,3),"_arg","");};var parameterCount=function parameterCount(fn){if(typeof fn.length==="number"){return Math.max(Math.min(fn.length,1023+1),0);}return 0;};makeNodePromisifiedEval=function makeNodePromisifiedEval(callback,receiver,originalName,fn,_,multiArgs){var newParameterCount=Math.max(0,parameterCount(fn)-1);var argumentOrder=switchCaseArgumentOrder(newParameterCount);var shouldProxyThis=typeof callback==="string"||receiver===THIS;function generateCallForArgumentCount(count){var args=argumentSequence(count).join(", ");var comma=count>0?", ":"";var ret;if(shouldProxyThis){ret="ret = callback.call(this, {{args}}, nodeback); break;\n";}else {ret=receiver===undefined?"ret = callback({{args}}, nodeback); break;\n":"ret = callback.call(receiver, {{args}}, nodeback); break;\n";}return ret.replace("{{args}}",args).replace(", ",comma);}function generateArgumentSwitchCase(){var ret="";for(var i=0;i<argumentOrder.length;++i){ret+="case "+argumentOrder[i]+":"+generateCallForArgumentCount(argumentOrder[i]);}ret+="                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]",shouldProxyThis?"ret = callback.apply(this, args);\n":"ret = callback.apply(receiver, args);\n");return ret;}var getFunctionCode=typeof callback==="string"?"this != null ? this['"+callback+"'] : fn":"fn";var body="'use strict';                                                \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise, "+multiArgs+");   \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	    ".replace("[CodeForSwitchCase]",generateArgumentSwitchCase()).replace("[GetFunctionCode]",getFunctionCode);body=body.replace("Parameters",parameterDeclaration(newParameterCount));return new Function("Promise","fn","receiver","withAppended","maybeWrapAsError","nodebackForPromise","tryCatch","errorObj","notEnumerableProp","INTERNAL",body)(Promise,fn,receiver,withAppended,maybeWrapAsError,nodebackForPromise,util.tryCatch,util.errorObj,util.notEnumerableProp,INTERNAL);};}function makeNodePromisifiedClosure(callback,receiver,_,fn,__,multiArgs){var defaultThis=function(){return this;}();var method=callback;if(typeof method==="string"){callback=fn;}function promisified(){var _receiver=receiver;if(receiver===THIS)_receiver=this;var promise=new Promise(INTERNAL);promise._captureStackTrace();var cb=typeof method==="string"&&this!==defaultThis?this[method]:callback;var fn=nodebackForPromise(promise,multiArgs);try{cb.apply(_receiver,withAppended(arguments,fn));}catch(e){promise._rejectCallback(maybeWrapAsError(e),true,true);}if(!promise._isFateSealed())promise._setAsyncGuaranteed();return promise;}util.notEnumerableProp(promisified,"__isPromisified__",true);return promisified;}var makeNodePromisified=canEvaluate?makeNodePromisifiedEval:makeNodePromisifiedClosure;function promisifyAll(obj,suffix,filter,promisifier,multiArgs){var suffixRegexp=new RegExp(escapeIdentRegex(suffix)+"$");var methods=promisifiableMethods(obj,suffix,suffixRegexp,filter);for(var i=0,len=methods.length;i<len;i+=2){var key=methods[i];var fn=methods[i+1];var promisifiedKey=key+suffix;if(promisifier===makeNodePromisified){obj[promisifiedKey]=makeNodePromisified(key,THIS,key,fn,suffix,multiArgs);}else {var promisified=promisifier(fn,function(){return makeNodePromisified(key,THIS,key,fn,suffix,multiArgs);});util.notEnumerableProp(promisified,"__isPromisified__",true);obj[promisifiedKey]=promisified;}}util.toFastProperties(obj);return obj;}function promisify(callback,receiver,multiArgs){return makeNodePromisified(callback,receiver,undefined,callback,null,multiArgs);}Promise.promisify=function(fn,options){if(typeof fn!=="function"){throw new TypeError("expecting a function but got "+util.classString(fn));}if(isPromisified(fn)){return fn;}options=Object(options);var receiver=options.context===undefined?THIS:options.context;var multiArgs=!!options.multiArgs;var ret=promisify(fn,receiver,multiArgs);util.copyDescriptors(fn,ret,propsFilter);return ret;};Promise.promisifyAll=function(target,options){if(typeof target!=="function"&&(typeof target==="undefined"?"undefined":_typeof(target))!=="object"){throw new TypeError("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");}options=Object(options);var multiArgs=!!options.multiArgs;var suffix=options.suffix;if(typeof suffix!=="string")suffix=defaultSuffix;var filter=options.filter;if(typeof filter!=="function")filter=defaultFilter;var promisifier=options.promisifier;if(typeof promisifier!=="function")promisifier=makeNodePromisified;if(!util.isIdentifier(suffix)){throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");}var keys=util.inheritedDataKeys(target);for(var i=0;i<keys.length;++i){var value=target[keys[i]];if(keys[i]!=="constructor"&&util.isClass(value)){promisifyAll(value.prototype,suffix,filter,promisifier,multiArgs);promisifyAll(value,suffix,filter,promisifier,multiArgs);}}return promisifyAll(target,suffix,filter,promisifier,multiArgs);};};},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,tryConvertToPromise,apiRejection){var util=_dereq_("./util");var isObject=util.isObject;var es5=_dereq_("./es5");var Es6Map;if(typeof Map==="function")Es6Map=Map;var mapToEntries=function(){var index=0;var size=0;function extractEntry(value,key){this[index]=value;this[index+size]=key;index++;}return function mapToEntries(map){size=map.size;index=0;var ret=new Array(map.size*2);map.forEach(extractEntry,ret);return ret;};}();var entriesToMap=function entriesToMap(entries){var ret=new Es6Map();var length=entries.length/2|0;for(var i=0;i<length;++i){var key=entries[length+i];var value=entries[i];ret.set(key,value);}return ret;};function PropertiesPromiseArray(obj){var isMap=false;var entries;if(Es6Map!==undefined&&obj instanceof Es6Map){entries=mapToEntries(obj);isMap=true;}else {var keys=es5.keys(obj);var len=keys.length;entries=new Array(len*2);for(var i=0;i<len;++i){var key=keys[i];entries[i]=obj[key];entries[i+len]=key;}}this.constructor$(entries);this._isMap=isMap;this._init$(undefined,-3);}util.inherits(PropertiesPromiseArray,PromiseArray);PropertiesPromiseArray.prototype._init=function(){};PropertiesPromiseArray.prototype._promiseFulfilled=function(value,index){this._values[index]=value;var totalResolved=++this._totalResolved;if(totalResolved>=this._length){var val;if(this._isMap){val=entriesToMap(this._values);}else {val={};var keyOffset=this.length();for(var i=0,len=this.length();i<len;++i){val[this._values[i+keyOffset]]=this._values[i];}}this._resolve(val);return true;}return false;};PropertiesPromiseArray.prototype.shouldCopyValues=function(){return false;};PropertiesPromiseArray.prototype.getActualLength=function(len){return len>>1;};function props(promises){var ret;var castValue=tryConvertToPromise(promises);if(!isObject(castValue)){return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");}else if(castValue instanceof Promise){ret=castValue._then(Promise.props,undefined,undefined,undefined,undefined);}else {ret=new PropertiesPromiseArray(castValue).promise();}if(castValue instanceof Promise){ret._propagateFrom(castValue,2);}return ret;}Promise.prototype.props=function(){return props(this);};Promise.props=function(promises){return props(promises);};};},{"./es5":13,"./util":36}],26:[function(_dereq_,module,exports){"use strict";function arrayMove(src,srcIndex,dst,dstIndex,len){for(var j=0;j<len;++j){dst[j+dstIndex]=src[j+srcIndex];src[j+srcIndex]=void 0;}}function Queue(capacity){this._capacity=capacity;this._length=0;this._front=0;}Queue.prototype._willBeOverCapacity=function(size){return this._capacity<size;};Queue.prototype._pushOne=function(arg){var length=this.length();this._checkCapacity(length+1);var i=this._front+length&this._capacity-1;this[i]=arg;this._length=length+1;};Queue.prototype._unshiftOne=function(value){var capacity=this._capacity;this._checkCapacity(this.length()+1);var front=this._front;var i=(front-1&capacity-1^capacity)-capacity;this[i]=value;this._front=i;this._length=this.length()+1;};Queue.prototype.unshift=function(fn,receiver,arg){this._unshiftOne(arg);this._unshiftOne(receiver);this._unshiftOne(fn);};Queue.prototype.push=function(fn,receiver,arg){var length=this.length()+3;if(this._willBeOverCapacity(length)){this._pushOne(fn);this._pushOne(receiver);this._pushOne(arg);return;}var j=this._front+length-3;this._checkCapacity(length);var wrapMask=this._capacity-1;this[j+0&wrapMask]=fn;this[j+1&wrapMask]=receiver;this[j+2&wrapMask]=arg;this._length=length;};Queue.prototype.shift=function(){var front=this._front,ret=this[front];this[front]=undefined;this._front=front+1&this._capacity-1;this._length--;return ret;};Queue.prototype.length=function(){return this._length;};Queue.prototype._checkCapacity=function(size){if(this._capacity<size){this._resizeTo(this._capacity<<1);}};Queue.prototype._resizeTo=function(capacity){var oldCapacity=this._capacity;this._capacity=capacity;var front=this._front;var length=this._length;var moveItemsCount=front+length&oldCapacity-1;arrayMove(this,0,this,oldCapacity,moveItemsCount);};module.exports=Queue;},{}],27:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL,tryConvertToPromise,apiRejection){var util=_dereq_("./util");var raceLater=function raceLater(promise){return promise.then(function(array){return race(array,promise);});};function race(promises,parent){var maybePromise=tryConvertToPromise(promises);if(maybePromise instanceof Promise){return raceLater(maybePromise);}else {promises=util.asArray(promises);if(promises===null)return apiRejection("expecting an array or an iterable object but got "+util.classString(promises));}var ret=new Promise(INTERNAL);if(parent!==undefined){ret._propagateFrom(parent,3);}var fulfill=ret._fulfill;var reject=ret._reject;for(var i=0,len=promises.length;i<len;++i){var val=promises[i];if(val===undefined&&!(i in promises)){continue;}Promise.cast(val)._then(fulfill,reject,undefined,ret,null);}return ret;}Promise.race=function(promises){return race(promises,undefined);};Promise.prototype.race=function(){return race(this,undefined);};};},{"./util":36}],28:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,apiRejection,tryConvertToPromise,INTERNAL,debug){var getDomain=Promise._getDomain;var util=_dereq_("./util");var tryCatch=util.tryCatch;function ReductionPromiseArray(promises,fn,initialValue,_each){this.constructor$(promises);var domain=getDomain();this._fn=domain===null?fn:domain.bind(fn);if(initialValue!==undefined){initialValue=Promise.resolve(initialValue);initialValue._attachCancellationCallback(this);}this._initialValue=initialValue;this._currentCancellable=null;this._eachValues=_each===INTERNAL?[]:undefined;this._promise._captureStackTrace();this._init$(undefined,-5);}util.inherits(ReductionPromiseArray,PromiseArray);ReductionPromiseArray.prototype._gotAccum=function(accum){if(this._eachValues!==undefined&&accum!==INTERNAL){this._eachValues.push(accum);}};ReductionPromiseArray.prototype._eachComplete=function(value){this._eachValues.push(value);return this._eachValues;};ReductionPromiseArray.prototype._init=function(){};ReductionPromiseArray.prototype._resolveEmptyArray=function(){this._resolve(this._eachValues!==undefined?this._eachValues:this._initialValue);};ReductionPromiseArray.prototype.shouldCopyValues=function(){return false;};ReductionPromiseArray.prototype._resolve=function(value){this._promise._resolveCallback(value);this._values=null;};ReductionPromiseArray.prototype._resultCancelled=function(sender){if(sender===this._initialValue)return this._cancel();if(this._isResolved())return;this._resultCancelled$();if(this._currentCancellable instanceof Promise){this._currentCancellable.cancel();}if(this._initialValue instanceof Promise){this._initialValue.cancel();}};ReductionPromiseArray.prototype._iterate=function(values){this._values=values;var value;var i;var length=values.length;if(this._initialValue!==undefined){value=this._initialValue;i=0;}else {value=Promise.resolve(values[0]);i=1;}this._currentCancellable=value;if(!value.isRejected()){for(;i<length;++i){var ctx={accum:null,value:values[i],index:i,length:length,array:this};value=value._then(gotAccum,undefined,undefined,ctx,undefined);}}if(this._eachValues!==undefined){value=value._then(this._eachComplete,undefined,undefined,this,undefined);}value._then(completed,completed,undefined,value,this);};Promise.prototype.reduce=function(fn,initialValue){return reduce(this,fn,initialValue,null);};Promise.reduce=function(promises,fn,initialValue,_each){return reduce(promises,fn,initialValue,_each);};function completed(valueOrReason,array){if(this.isFulfilled()){array._resolve(valueOrReason);}else {array._reject(valueOrReason);}}function reduce(promises,fn,initialValue,_each){if(typeof fn!=="function"){return apiRejection("expecting a function but got "+util.classString(fn));}var array=new ReductionPromiseArray(promises,fn,initialValue,_each);return array.promise();}function gotAccum(accum){this.accum=accum;this.array._gotAccum(accum);var value=tryConvertToPromise(this.value,this.array._promise);if(value instanceof Promise){this.array._currentCancellable=value;return value._then(gotValue,undefined,undefined,this,undefined);}else {return gotValue.call(this,value);}}function gotValue(value){var array=this.array;var promise=array._promise;var fn=tryCatch(array._fn);promise._pushContext();var ret;if(array._eachValues!==undefined){ret=fn.call(promise._boundValue(),value,this.index,this.length);}else {ret=fn.call(promise._boundValue(),this.accum,value,this.index,this.length);}if(ret instanceof Promise){array._currentCancellable=ret;}var promiseCreated=promise._popContext();debug.checkForgottenReturns(ret,promiseCreated,array._eachValues!==undefined?"Promise.each":"Promise.reduce",promise);return ret;}};},{"./util":36}],29:[function(_dereq_,module,exports){"use strict";var util=_dereq_("./util");var schedule;var noAsyncScheduler=function noAsyncScheduler(){throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");};var NativePromise=util.getNativePromise();if(util.isNode&&typeof MutationObserver==="undefined"){var GlobalSetImmediate=global.setImmediate;var ProcessNextTick=process.nextTick;schedule=util.isRecentNode?function(fn){GlobalSetImmediate.call(global,fn);}:function(fn){ProcessNextTick.call(process,fn);};}else if(typeof NativePromise==="function"){var nativePromise=NativePromise.resolve();schedule=function schedule(fn){nativePromise.then(fn);};}else if(typeof MutationObserver!=="undefined"&&!(typeof window!=="undefined"&&window.navigator&&window.navigator.standalone)){schedule=function(){var div=document.createElement("div");var opts={attributes:true};var toggleScheduled=false;var div2=document.createElement("div");var o2=new MutationObserver(function(){div.classList.toggle("foo");toggleScheduled=false;});o2.observe(div2,opts);var scheduleToggle=function scheduleToggle(){if(toggleScheduled)return;toggleScheduled=true;div2.classList.toggle("foo");};return function schedule(fn){var o=new MutationObserver(function(){o.disconnect();fn();});o.observe(div,opts);scheduleToggle();};}();}else if(typeof setImmediate!=="undefined"){schedule=function schedule(fn){setImmediate(fn);};}else if(typeof setTimeout!=="undefined"){schedule=function schedule(fn){setTimeout(fn,0);};}else {schedule=noAsyncScheduler;}module.exports=schedule;},{"./util":36}],30:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,debug){var PromiseInspection=Promise.PromiseInspection;var util=_dereq_("./util");function SettledPromiseArray(values){this.constructor$(values);}util.inherits(SettledPromiseArray,PromiseArray);SettledPromiseArray.prototype._promiseResolved=function(index,inspection){this._values[index]=inspection;var totalResolved=++this._totalResolved;if(totalResolved>=this._length){this._resolve(this._values);return true;}return false;};SettledPromiseArray.prototype._promiseFulfilled=function(value,index){var ret=new PromiseInspection();ret._bitField=33554432;ret._settledValueField=value;return this._promiseResolved(index,ret);};SettledPromiseArray.prototype._promiseRejected=function(reason,index){var ret=new PromiseInspection();ret._bitField=16777216;ret._settledValueField=reason;return this._promiseResolved(index,ret);};Promise.settle=function(promises){debug.deprecated(".settle()",".reflect()");return new SettledPromiseArray(promises).promise();};Promise.prototype.settle=function(){return Promise.settle(this);};};},{"./util":36}],31:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,PromiseArray,apiRejection){var util=_dereq_("./util");var RangeError=_dereq_("./errors").RangeError;var AggregateError=_dereq_("./errors").AggregateError;var isArray=util.isArray;var CANCELLATION={};function SomePromiseArray(values){this.constructor$(values);this._howMany=0;this._unwrap=false;this._initialized=false;}util.inherits(SomePromiseArray,PromiseArray);SomePromiseArray.prototype._init=function(){if(!this._initialized){return;}if(this._howMany===0){this._resolve([]);return;}this._init$(undefined,-5);var isArrayResolved=isArray(this._values);if(!this._isResolved()&&isArrayResolved&&this._howMany>this._canPossiblyFulfill()){this._reject(this._getRangeError(this.length()));}};SomePromiseArray.prototype.init=function(){this._initialized=true;this._init();};SomePromiseArray.prototype.setUnwrap=function(){this._unwrap=true;};SomePromiseArray.prototype.howMany=function(){return this._howMany;};SomePromiseArray.prototype.setHowMany=function(count){this._howMany=count;};SomePromiseArray.prototype._promiseFulfilled=function(value){this._addFulfilled(value);if(this._fulfilled()===this.howMany()){this._values.length=this.howMany();if(this.howMany()===1&&this._unwrap){this._resolve(this._values[0]);}else {this._resolve(this._values);}return true;}return false;};SomePromiseArray.prototype._promiseRejected=function(reason){this._addRejected(reason);return this._checkOutcome();};SomePromiseArray.prototype._promiseCancelled=function(){if(this._values instanceof Promise||this._values==null){return this._cancel();}this._addRejected(CANCELLATION);return this._checkOutcome();};SomePromiseArray.prototype._checkOutcome=function(){if(this.howMany()>this._canPossiblyFulfill()){var e=new AggregateError();for(var i=this.length();i<this._values.length;++i){if(this._values[i]!==CANCELLATION){e.push(this._values[i]);}}if(e.length>0){this._reject(e);}else {this._cancel();}return true;}return false;};SomePromiseArray.prototype._fulfilled=function(){return this._totalResolved;};SomePromiseArray.prototype._rejected=function(){return this._values.length-this.length();};SomePromiseArray.prototype._addRejected=function(reason){this._values.push(reason);};SomePromiseArray.prototype._addFulfilled=function(value){this._values[this._totalResolved++]=value;};SomePromiseArray.prototype._canPossiblyFulfill=function(){return this.length()-this._rejected();};SomePromiseArray.prototype._getRangeError=function(count){var message="Input array must contain at least "+this._howMany+" items but contains only "+count+" items";return new RangeError(message);};SomePromiseArray.prototype._resolveEmptyArray=function(){this._reject(this._getRangeError(0));};function some(promises,howMany){if((howMany|0)!==howMany||howMany<0){return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");}var ret=new SomePromiseArray(promises);var promise=ret.promise();ret.setHowMany(howMany);ret.init();return promise;}Promise.some=function(promises,howMany){return some(promises,howMany);};Promise.prototype.some=function(howMany){return some(this,howMany);};Promise._SomePromiseArray=SomePromiseArray;};},{"./errors":12,"./util":36}],32:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise){function PromiseInspection(promise){if(promise!==undefined){promise=promise._target();this._bitField=promise._bitField;this._settledValueField=promise._isFateSealed()?promise._settledValue():undefined;}else {this._bitField=0;this._settledValueField=undefined;}}PromiseInspection.prototype._settledValue=function(){return this._settledValueField;};var value=PromiseInspection.prototype.value=function(){if(!this.isFulfilled()){throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");}return this._settledValue();};var reason=PromiseInspection.prototype.error=PromiseInspection.prototype.reason=function(){if(!this.isRejected()){throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");}return this._settledValue();};var isFulfilled=PromiseInspection.prototype.isFulfilled=function(){return (this._bitField&33554432)!==0;};var isRejected=PromiseInspection.prototype.isRejected=function(){return (this._bitField&16777216)!==0;};var isPending=PromiseInspection.prototype.isPending=function(){return (this._bitField&50397184)===0;};var isResolved=PromiseInspection.prototype.isResolved=function(){return (this._bitField&50331648)!==0;};PromiseInspection.prototype.isCancelled=Promise.prototype._isCancelled=function(){return (this._bitField&65536)===65536;};Promise.prototype.isCancelled=function(){return this._target()._isCancelled();};Promise.prototype.isPending=function(){return isPending.call(this._target());};Promise.prototype.isRejected=function(){return isRejected.call(this._target());};Promise.prototype.isFulfilled=function(){return isFulfilled.call(this._target());};Promise.prototype.isResolved=function(){return isResolved.call(this._target());};Promise.prototype.value=function(){return value.call(this._target());};Promise.prototype.reason=function(){var target=this._target();target._unsetRejectionIsUnhandled();return reason.call(target);};Promise.prototype._value=function(){return this._settledValue();};Promise.prototype._reason=function(){this._unsetRejectionIsUnhandled();return this._settledValue();};Promise.PromiseInspection=PromiseInspection;};},{}],33:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL){var util=_dereq_("./util");var errorObj=util.errorObj;var isObject=util.isObject;function tryConvertToPromise(obj,context){if(isObject(obj)){if(obj instanceof Promise)return obj;var then=getThen(obj);if(then===errorObj){if(context)context._pushContext();var ret=Promise.reject(then.e);if(context)context._popContext();return ret;}else if(typeof then==="function"){if(isAnyBluebirdPromise(obj)){var ret=new Promise(INTERNAL);obj._then(ret._fulfill,ret._reject,undefined,ret,null);return ret;}return doThenable(obj,then,context);}}return obj;}function doGetThen(obj){return obj.then;}function getThen(obj){try{return doGetThen(obj);}catch(e){errorObj.e=e;return errorObj;}}var hasProp={}.hasOwnProperty;function isAnyBluebirdPromise(obj){try{return hasProp.call(obj,"_promise0");}catch(e){return false;}}function doThenable(x,then,context){var promise=new Promise(INTERNAL);var ret=promise;if(context)context._pushContext();promise._captureStackTrace();if(context)context._popContext();var synchronous=true;var result=util.tryCatch(then).call(x,resolve,reject);synchronous=false;if(promise&&result===errorObj){promise._rejectCallback(result.e,true,true);promise=null;}function resolve(value){if(!promise)return;promise._resolveCallback(value);promise=null;}function reject(reason){if(!promise)return;promise._rejectCallback(reason,synchronous,true);promise=null;}return ret;}return tryConvertToPromise;};},{"./util":36}],34:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,INTERNAL,debug){var util=_dereq_("./util");var TimeoutError=Promise.TimeoutError;function HandleWrapper(handle){this.handle=handle;}HandleWrapper.prototype._resultCancelled=function(){clearTimeout(this.handle);};var afterValue=function afterValue(value){return delay(+this).thenReturn(value);};var delay=Promise.delay=function(ms,value){var ret;var handle;if(value!==undefined){ret=Promise.resolve(value)._then(afterValue,null,null,ms,undefined);if(debug.cancellation()&&value instanceof Promise){ret._setOnCancel(value);}}else {ret=new Promise(INTERNAL);handle=setTimeout(function(){ret._fulfill();},+ms);if(debug.cancellation()){ret._setOnCancel(new HandleWrapper(handle));}}ret._setAsyncGuaranteed();return ret;};Promise.prototype.delay=function(ms){return delay(ms,this);};var afterTimeout=function afterTimeout(promise,message,parent){var err;if(typeof message!=="string"){if(message instanceof Error){err=message;}else {err=new TimeoutError("operation timed out");}}else {err=new TimeoutError(message);}util.markAsOriginatingFromRejection(err);promise._attachExtraTrace(err);promise._reject(err);if(parent!=null){parent.cancel();}};function successClear(value){clearTimeout(this.handle);return value;}function failureClear(reason){clearTimeout(this.handle);throw reason;}Promise.prototype.timeout=function(ms,message){ms=+ms;var ret,parent;var handleWrapper=new HandleWrapper(setTimeout(function timeoutTimeout(){if(ret.isPending()){afterTimeout(ret,message,parent);}},ms));if(debug.cancellation()){parent=this.then();ret=parent._then(successClear,failureClear,undefined,handleWrapper,undefined);ret._setOnCancel(handleWrapper);}else {ret=this._then(successClear,failureClear,undefined,handleWrapper,undefined);}return ret;};};},{"./util":36}],35:[function(_dereq_,module,exports){"use strict";module.exports=function(Promise,apiRejection,tryConvertToPromise,createContext,INTERNAL,debug){var util=_dereq_("./util");var TypeError=_dereq_("./errors").TypeError;var inherits=_dereq_("./util").inherits;var errorObj=util.errorObj;var tryCatch=util.tryCatch;var NULL={};function thrower(e){setTimeout(function(){throw e;},0);}function castPreservingDisposable(thenable){var maybePromise=tryConvertToPromise(thenable);if(maybePromise!==thenable&&typeof thenable._isDisposable==="function"&&typeof thenable._getDisposer==="function"&&thenable._isDisposable()){maybePromise._setDisposable(thenable._getDisposer());}return maybePromise;}function dispose(resources,inspection){var i=0;var len=resources.length;var ret=new Promise(INTERNAL);function iterator(){if(i>=len)return ret._fulfill();var maybePromise=castPreservingDisposable(resources[i++]);if(maybePromise instanceof Promise&&maybePromise._isDisposable()){try{maybePromise=tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection),resources.promise);}catch(e){return thrower(e);}if(maybePromise instanceof Promise){return maybePromise._then(iterator,thrower,null,null,null);}}iterator();}iterator();return ret;}function Disposer(data,promise,context){this._data=data;this._promise=promise;this._context=context;}Disposer.prototype.data=function(){return this._data;};Disposer.prototype.promise=function(){return this._promise;};Disposer.prototype.resource=function(){if(this.promise().isFulfilled()){return this.promise().value();}return NULL;};Disposer.prototype.tryDispose=function(inspection){var resource=this.resource();var context=this._context;if(context!==undefined)context._pushContext();var ret=resource!==NULL?this.doDispose(resource,inspection):null;if(context!==undefined)context._popContext();this._promise._unsetDisposable();this._data=null;return ret;};Disposer.isDisposer=function(d){return d!=null&&typeof d.resource==="function"&&typeof d.tryDispose==="function";};function FunctionDisposer(fn,promise,context){this.constructor$(fn,promise,context);}inherits(FunctionDisposer,Disposer);FunctionDisposer.prototype.doDispose=function(resource,inspection){var fn=this.data();return fn.call(resource,resource,inspection);};function maybeUnwrapDisposer(value){if(Disposer.isDisposer(value)){this.resources[this.index]._setDisposable(value);return value.promise();}return value;}function ResourceList(length){this.length=length;this.promise=null;this[length-1]=null;}ResourceList.prototype._resultCancelled=function(){var len=this.length;for(var i=0;i<len;++i){var item=this[i];if(item instanceof Promise){item.cancel();}}};Promise.using=function(){var len=arguments.length;if(len<2)return apiRejection("you must pass at least 2 arguments to Promise.using");var fn=arguments[len-1];if(typeof fn!=="function"){return apiRejection("expecting a function but got "+util.classString(fn));}var input;var spreadArgs=true;if(len===2&&Array.isArray(arguments[0])){input=arguments[0];len=input.length;spreadArgs=false;}else {input=arguments;len--;}var resources=new ResourceList(len);for(var i=0;i<len;++i){var resource=input[i];if(Disposer.isDisposer(resource)){var disposer=resource;resource=resource.promise();resource._setDisposable(disposer);}else {var maybePromise=tryConvertToPromise(resource);if(maybePromise instanceof Promise){resource=maybePromise._then(maybeUnwrapDisposer,null,null,{resources:resources,index:i},undefined);}}resources[i]=resource;}var reflectedResources=new Array(resources.length);for(var i=0;i<reflectedResources.length;++i){reflectedResources[i]=Promise.resolve(resources[i]).reflect();}var resultPromise=Promise.all(reflectedResources).then(function(inspections){for(var i=0;i<inspections.length;++i){var inspection=inspections[i];if(inspection.isRejected()){errorObj.e=inspection.error();return errorObj;}else if(!inspection.isFulfilled()){resultPromise.cancel();return;}inspections[i]=inspection.value();}promise._pushContext();fn=tryCatch(fn);var ret=spreadArgs?fn.apply(undefined,inspections):fn(inspections);var promiseCreated=promise._popContext();debug.checkForgottenReturns(ret,promiseCreated,"Promise.using",promise);return ret;});var promise=resultPromise.lastly(function(){var inspection=new Promise.PromiseInspection(resultPromise);return dispose(resources,inspection);});resources.promise=promise;promise._setOnCancel(resources);return promise;};Promise.prototype._setDisposable=function(disposer){this._bitField=this._bitField|131072;this._disposer=disposer;};Promise.prototype._isDisposable=function(){return (this._bitField&131072)>0;};Promise.prototype._getDisposer=function(){return this._disposer;};Promise.prototype._unsetDisposable=function(){this._bitField=this._bitField&~131072;this._disposer=undefined;};Promise.prototype.disposer=function(fn){if(typeof fn==="function"){return new FunctionDisposer(fn,this,createContext());}throw new TypeError();};};},{"./errors":12,"./util":36}],36:[function(_dereq_,module,exports){"use strict";var es5=_dereq_("./es5");var canEvaluate=typeof navigator=="undefined";var errorObj={e:{}};var tryCatchTarget;var globalObject=typeof self!=="undefined"?self:typeof window!=="undefined"?window:typeof global!=="undefined"?global:this!==undefined?this:null;function tryCatcher(){try{var target=tryCatchTarget;tryCatchTarget=null;return target.apply(this,arguments);}catch(e){errorObj.e=e;return errorObj;}}function tryCatch(fn){tryCatchTarget=fn;return tryCatcher;}var inherits=function inherits(Child,Parent){var hasProp={}.hasOwnProperty;function T(){this.constructor=Child;this.constructor$=Parent;for(var propertyName in Parent.prototype){if(hasProp.call(Parent.prototype,propertyName)&&propertyName.charAt(propertyName.length-1)!=="$"){this[propertyName+"$"]=Parent.prototype[propertyName];}}}T.prototype=Parent.prototype;Child.prototype=new T();return Child.prototype;};function isPrimitive(val){return val==null||val===true||val===false||typeof val==="string"||typeof val==="number";}function isObject(value){return typeof value==="function"||(typeof value==="undefined"?"undefined":_typeof(value))==="object"&&value!==null;}function maybeWrapAsError(maybeError){if(!isPrimitive(maybeError))return maybeError;return new Error(safeToString(maybeError));}function withAppended(target,appendee){var len=target.length;var ret=new Array(len+1);var i;for(i=0;i<len;++i){ret[i]=target[i];}ret[i]=appendee;return ret;}function getDataPropertyOrDefault(obj,key,defaultValue){if(es5.isES5){var desc=Object.getOwnPropertyDescriptor(obj,key);if(desc!=null){return desc.get==null&&desc.set==null?desc.value:defaultValue;}}else {return {}.hasOwnProperty.call(obj,key)?obj[key]:undefined;}}function notEnumerableProp(obj,name,value){if(isPrimitive(obj))return obj;var descriptor={value:value,configurable:true,enumerable:false,writable:true};es5.defineProperty(obj,name,descriptor);return obj;}function thrower(r){throw r;}var inheritedDataKeys=function(){var excludedPrototypes=[Array.prototype,Object.prototype,Function.prototype];var isExcludedProto=function isExcludedProto(val){for(var i=0;i<excludedPrototypes.length;++i){if(excludedPrototypes[i]===val){return true;}}return false;};if(es5.isES5){var getKeys=Object.getOwnPropertyNames;return function(obj){var ret=[];var visitedKeys=Object.create(null);while(obj!=null&&!isExcludedProto(obj)){var keys;try{keys=getKeys(obj);}catch(e){return ret;}for(var i=0;i<keys.length;++i){var key=keys[i];if(visitedKeys[key])continue;visitedKeys[key]=true;var desc=Object.getOwnPropertyDescriptor(obj,key);if(desc!=null&&desc.get==null&&desc.set==null){ret.push(key);}}obj=es5.getPrototypeOf(obj);}return ret;};}else {var hasProp={}.hasOwnProperty;return function(obj){if(isExcludedProto(obj))return [];var ret=[]; /*jshint forin:false */enumeration: for(var key in obj){if(hasProp.call(obj,key)){ret.push(key);}else {for(var i=0;i<excludedPrototypes.length;++i){if(hasProp.call(excludedPrototypes[i],key)){continue enumeration;}}ret.push(key);}}return ret;};}}();var thisAssignmentPattern=/this\s*\.\s*\S+\s*=/;function isClass(fn){try{if(typeof fn==="function"){var keys=es5.names(fn.prototype);var hasMethods=es5.isES5&&keys.length>1;var hasMethodsOtherThanConstructor=keys.length>0&&!(keys.length===1&&keys[0]==="constructor");var hasThisAssignmentAndStaticMethods=thisAssignmentPattern.test(fn+"")&&es5.names(fn).length>0;if(hasMethods||hasMethodsOtherThanConstructor||hasThisAssignmentAndStaticMethods){return true;}}return false;}catch(e){return false;}}function toFastProperties(obj){ /*jshint -W027,-W055,-W031*/function FakeConstructor(){}FakeConstructor.prototype=obj;var l=8;while(l--){new FakeConstructor();}return obj;eval(obj);}var rident=/^[a-z$_][a-z$_0-9]*$/i;function isIdentifier(str){return rident.test(str);}function filledRange(count,prefix,suffix){var ret=new Array(count);for(var i=0;i<count;++i){ret[i]=prefix+i+suffix;}return ret;}function safeToString(obj){try{return obj+"";}catch(e){return "[no string representation]";}}function isError(obj){return obj!==null&&(typeof obj==="undefined"?"undefined":_typeof(obj))==="object"&&typeof obj.message==="string"&&typeof obj.name==="string";}function markAsOriginatingFromRejection(e){try{notEnumerableProp(e,"isOperational",true);}catch(ignore){}}function originatesFromRejection(e){if(e==null)return false;return e instanceof Error["__BluebirdErrorTypes__"].OperationalError||e["isOperational"]===true;}function canAttachTrace(obj){return isError(obj)&&es5.propertyIsWritable(obj,"stack");}var ensureErrorObject=function(){if(!("stack" in new Error())){return function(value){if(canAttachTrace(value))return value;try{throw new Error(safeToString(value));}catch(err){return err;}};}else {return function(value){if(canAttachTrace(value))return value;return new Error(safeToString(value));};}}();function classString(obj){return {}.toString.call(obj);}function copyDescriptors(from,to,filter){var keys=es5.names(from);for(var i=0;i<keys.length;++i){var key=keys[i];if(filter(key)){try{es5.defineProperty(to,key,es5.getDescriptor(from,key));}catch(ignore){}}}}var asArray=function asArray(v){if(es5.isArray(v)){return v;}return null;};if(typeof Symbol!=="undefined"&&Symbol.iterator){var ArrayFrom=typeof Array.from==="function"?function(v){return Array.from(v);}:function(v){var ret=[];var it=v[Symbol.iterator]();var itResult;while(!(itResult=it.next()).done){ret.push(itResult.value);}return ret;};asArray=function asArray(v){if(es5.isArray(v)){return v;}else if(v!=null&&typeof v[Symbol.iterator]==="function"){return ArrayFrom(v);}return null;};}var isNode=typeof process!=="undefined"&&classString(process).toLowerCase()==="[object process]";function env(key,def){return isNode?process.env[key]:def;}function getNativePromise(){if(typeof Promise==="function"){try{var promise=new Promise(function(){});if({}.toString.call(promise)==="[object Promise]"){return Promise;}}catch(e){}}}var ret={isClass:isClass,isIdentifier:isIdentifier,inheritedDataKeys:inheritedDataKeys,getDataPropertyOrDefault:getDataPropertyOrDefault,thrower:thrower,isArray:es5.isArray,asArray:asArray,notEnumerableProp:notEnumerableProp,isPrimitive:isPrimitive,isObject:isObject,isError:isError,canEvaluate:canEvaluate,errorObj:errorObj,tryCatch:tryCatch,inherits:inherits,withAppended:withAppended,maybeWrapAsError:maybeWrapAsError,toFastProperties:toFastProperties,filledRange:filledRange,toString:safeToString,canAttachTrace:canAttachTrace,ensureErrorObject:ensureErrorObject,originatesFromRejection:originatesFromRejection,markAsOriginatingFromRejection:markAsOriginatingFromRejection,classString:classString,copyDescriptors:copyDescriptors,hasDevTools:typeof chrome!=="undefined"&&chrome&&typeof chrome.loadTimes==="function",isNode:isNode,env:env,global:globalObject,getNativePromise:getNativePromise};ret.isRecentNode=ret.isNode&&function(){var version=process.versions.node.split(".").map(Number);return version[0]===0&&version[1]>10||version[0]>0;}();if(ret.isNode)ret.toFastProperties(process);try{throw new Error();}catch(e){ret.lastLineError=e;}module.exports=ret;},{"./es5":13}]},{},[4])(4);});;if(typeof window!=='undefined'&&window!==null){window.P=window.Promise;}else if(typeof self!=='undefined'&&self!==null){self.P=self.Promise;}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), (function() { return this; }()), __webpack_require__(10).setImmediate))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {"use strict";

	var nextTick = __webpack_require__(1).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function () {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function () {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout = exports.clearInterval = function (timeout) {
	  timeout.close();
	};

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function () {};
	Timeout.prototype.close = function () {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function (item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function (item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function (item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout) item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).setImmediate, __webpack_require__(10).clearImmediate))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate, module) {"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	// vim:ts=4:sts=4:sw=4:
	/*!
	 *
	 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
	 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
	 *
	 * With parts by Tyler Close
	 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
	 * at http://www.opensource.org/licenses/mit-license.html
	 * Forked at ref_send.js version: 2009-05-11
	 *
	 * With parts by Mark Miller
	 * Copyright (C) 2011 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */

	(function (definition) {
	    "use strict";

	    // This file will function properly as a <script> tag, or a module
	    // using CommonJS and NodeJS or RequireJS module formats.  In
	    // Common/Node/RequireJS, the module exports the Q API and when
	    // executed as a simple <script>, it creates a Q global instead.

	    // Montage Require

	    if (typeof bootstrap === "function") {
	        bootstrap("promise", definition);

	        // CommonJS
	    } else if (( false ? "undefined" : _typeof(exports)) === "object" && ( false ? "undefined" : _typeof(module)) === "object") {
	            module.exports = definition();

	            // RequireJS
	        } else if (true) {
	                !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	                // SES (Secure EcmaScript)
	            } else if (typeof ses !== "undefined") {
	                    if (!ses.ok()) {
	                        return;
	                    } else {
	                        ses.makeQ = definition;
	                    }

	                    // <script>
	                } else if (typeof window !== "undefined" || typeof self !== "undefined") {
	                        // Prefer window over self for add-on scripts. Use self for
	                        // non-windowed contexts.
	                        var global = typeof window !== "undefined" ? window : self;

	                        // Get the `window` object, save the previous Q global
	                        // and initialize Q as a global.
	                        var previousQ = global.Q;
	                        global.Q = definition();

	                        // Add a noConflict function so Q can be removed from the
	                        // global namespace.
	                        global.Q.noConflict = function () {
	                            global.Q = previousQ;
	                            return this;
	                        };
	                    } else {
	                        throw new Error("This environment was not anticipated by Q. Please file a bug.");
	                    }
	})(function () {
	    "use strict";

	    var hasStacks = false;
	    try {
	        throw new Error();
	    } catch (e) {
	        hasStacks = !!e.stack;
	    }

	    // All code after this point will be filtered from stack traces reported
	    // by Q.
	    var qStartingLine = captureLine();
	    var qFileName;

	    // shims

	    // used for fallback in "allResolved"
	    var noop = function noop() {};

	    // Use the fastest possible means to execute a task in a future turn
	    // of the event loop.
	    var nextTick = function () {
	        // linked list of tasks (single, with head node)
	        var head = { task: void 0, next: null };
	        var tail = head;
	        var flushing = false;
	        var requestTick = void 0;
	        var isNodeJS = false;
	        // queue for late tasks, used by unhandled rejection tracking
	        var laterQueue = [];

	        function flush() {
	            /* jshint loopfunc: true */
	            var task, domain;

	            while (head.next) {
	                head = head.next;
	                task = head.task;
	                head.task = void 0;
	                domain = head.domain;

	                if (domain) {
	                    head.domain = void 0;
	                    domain.enter();
	                }
	                runSingle(task, domain);
	            }
	            while (laterQueue.length) {
	                task = laterQueue.pop();
	                runSingle(task);
	            }
	            flushing = false;
	        }
	        // runs a single function in the async queue
	        function runSingle(task, domain) {
	            try {
	                task();
	            } catch (e) {
	                if (isNodeJS) {
	                    // In node, uncaught exceptions are considered fatal errors.
	                    // Re-throw them synchronously to interrupt flushing!

	                    // Ensure continuation if the uncaught exception is suppressed
	                    // listening "uncaughtException" events (as domains does).
	                    // Continue in next event to avoid tick recursion.
	                    if (domain) {
	                        domain.exit();
	                    }
	                    setTimeout(flush, 0);
	                    if (domain) {
	                        domain.enter();
	                    }

	                    throw e;
	                } else {
	                    // In browsers, uncaught exceptions are not fatal.
	                    // Re-throw them asynchronously to avoid slow-downs.
	                    setTimeout(function () {
	                        throw e;
	                    }, 0);
	                }
	            }

	            if (domain) {
	                domain.exit();
	            }
	        }

	        nextTick = function nextTick(task) {
	            tail = tail.next = {
	                task: task,
	                domain: isNodeJS && process.domain,
	                next: null
	            };

	            if (!flushing) {
	                flushing = true;
	                requestTick();
	            }
	        };

	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process.toString() === "[object process]" && process.nextTick) {
	            // Ensure Q is in a real Node environment, with a `process.nextTick`.
	            // To see through fake Node environments:
	            // * Mocha test runner - exposes a `process` global without a `nextTick`
	            // * Browserify - exposes a `process.nexTick` function that uses
	            //   `setTimeout`. In this case `setImmediate` is preferred because
	            //    it is faster. Browserify's `process.toString()` yields
	            //   "[object Object]", while in a real Node environment
	            //   `process.nextTick()` yields "[object process]".
	            isNodeJS = true;

	            requestTick = function requestTick() {
	                process.nextTick(flush);
	            };
	        } else if (typeof setImmediate === "function") {
	            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	            if (typeof window !== "undefined") {
	                requestTick = setImmediate.bind(window, flush);
	            } else {
	                requestTick = function requestTick() {
	                    setImmediate(flush);
	                };
	            }
	        } else if (typeof MessageChannel !== "undefined") {
	            // modern browsers
	            // http://www.nonblocking.io/2011/06/windownexttick.html
	            var channel = new MessageChannel();
	            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
	            // working message ports the first time a page loads.
	            channel.port1.onmessage = function () {
	                requestTick = requestPortTick;
	                channel.port1.onmessage = flush;
	                flush();
	            };
	            var requestPortTick = function requestPortTick() {
	                // Opera requires us to provide a message payload, regardless of
	                // whether we use it.
	                channel.port2.postMessage(0);
	            };
	            requestTick = function requestTick() {
	                setTimeout(flush, 0);
	                requestPortTick();
	            };
	        } else {
	            // old browsers
	            requestTick = function requestTick() {
	                setTimeout(flush, 0);
	            };
	        }
	        // runs a task after all other tasks have been run
	        // this is useful for unhandled rejection tracking that needs to happen
	        // after all `then`d tasks have been run.
	        nextTick.runAfter = function (task) {
	            laterQueue.push(task);
	            if (!flushing) {
	                flushing = true;
	                requestTick();
	            }
	        };
	        return nextTick;
	    }();

	    // Attempt to make generics safe in the face of downstream
	    // modifications.
	    // There is no situation where this is necessary.
	    // If you need a security guarantee, these primordials need to be
	    // deeply frozen anyway, and if you dont need a security guarantee,
	    // this is just plain paranoid.
	    // However, this **might** have the nice side-effect of reducing the size of
	    // the minified code by reducing x.call() to merely x()
	    // See Mark Millers explanation of what this does.
	    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
	    var call = Function.call;
	    function uncurryThis(f) {
	        return function () {
	            return call.apply(f, arguments);
	        };
	    }
	    // This is equivalent, but slower:
	    // uncurryThis = Function_bind.bind(Function_bind.call);
	    // http://jsperf.com/uncurrythis

	    var array_slice = uncurryThis(Array.prototype.slice);

	    var array_reduce = uncurryThis(Array.prototype.reduce || function (callback, basis) {
	        var index = 0,
	            length = this.length;
	        // concerning the initial value, if one is not provided
	        if (arguments.length === 1) {
	            // seek to the first value in the array, accounting
	            // for the possibility that is is a sparse array
	            do {
	                if (index in this) {
	                    basis = this[index++];
	                    break;
	                }
	                if (++index >= length) {
	                    throw new TypeError();
	                }
	            } while (1);
	        }
	        // reduce
	        for (; index < length; index++) {
	            // account for the possibility that the array is sparse
	            if (index in this) {
	                basis = callback(basis, this[index], index);
	            }
	        }
	        return basis;
	    });

	    var array_indexOf = uncurryThis(Array.prototype.indexOf || function (value) {
	        // not a very good shim, but good enough for our one use of it
	        for (var i = 0; i < this.length; i++) {
	            if (this[i] === value) {
	                return i;
	            }
	        }
	        return -1;
	    });

	    var array_map = uncurryThis(Array.prototype.map || function (callback, thisp) {
	        var self = this;
	        var collect = [];
	        array_reduce(self, function (undefined, value, index) {
	            collect.push(callback.call(thisp, value, index, self));
	        }, void 0);
	        return collect;
	    });

	    var object_create = Object.create || function (prototype) {
	        function Type() {}
	        Type.prototype = prototype;
	        return new Type();
	    };

	    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

	    var object_keys = Object.keys || function (object) {
	        var keys = [];
	        for (var key in object) {
	            if (object_hasOwnProperty(object, key)) {
	                keys.push(key);
	            }
	        }
	        return keys;
	    };

	    var object_toString = uncurryThis(Object.prototype.toString);

	    function isObject(value) {
	        return value === Object(value);
	    }

	    // generator related shims

	    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.
	    function isStopIteration(exception) {
	        return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
	    }

	    // FIXME: Remove this helper and Q.return once ES6 generators are in
	    // SpiderMonkey.
	    var QReturnValue;
	    if (typeof ReturnValue !== "undefined") {
	        QReturnValue = ReturnValue;
	    } else {
	        QReturnValue = function QReturnValue(value) {
	            this.value = value;
	        };
	    }

	    // long stack traces

	    var STACK_JUMP_SEPARATOR = "From previous event:";

	    function makeStackTraceLong(error, promise) {
	        // If possible, transform the error stack trace by removing Node and Q
	        // cruft, then concatenating with the stack trace of `promise`. See #57.
	        if (hasStacks && promise.stack && (typeof error === "undefined" ? "undefined" : _typeof(error)) === "object" && error !== null && error.stack && error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1) {
	            var stacks = [];
	            for (var p = promise; !!p; p = p.source) {
	                if (p.stack) {
	                    stacks.unshift(p.stack);
	                }
	            }
	            stacks.unshift(error.stack);

	            var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
	            error.stack = filterStackString(concatedStacks);
	        }
	    }

	    function filterStackString(stackString) {
	        var lines = stackString.split("\n");
	        var desiredLines = [];
	        for (var i = 0; i < lines.length; ++i) {
	            var line = lines[i];

	            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
	                desiredLines.push(line);
	            }
	        }
	        return desiredLines.join("\n");
	    }

	    function isNodeFrame(stackLine) {
	        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
	    }

	    function getFileNameAndLineNumber(stackLine) {
	        // Named functions: "at functionName (filename:lineNumber:columnNumber)"
	        // In IE10 function name can have spaces ("Anonymous function") O_o
	        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
	        if (attempt1) {
	            return [attempt1[1], Number(attempt1[2])];
	        }

	        // Anonymous functions: "at filename:lineNumber:columnNumber"
	        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
	        if (attempt2) {
	            return [attempt2[1], Number(attempt2[2])];
	        }

	        // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
	        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
	        if (attempt3) {
	            return [attempt3[1], Number(attempt3[2])];
	        }
	    }

	    function isInternalFrame(stackLine) {
	        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

	        if (!fileNameAndLineNumber) {
	            return false;
	        }

	        var fileName = fileNameAndLineNumber[0];
	        var lineNumber = fileNameAndLineNumber[1];

	        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
	    }

	    // discover own file name and line number range for filtering stack
	    // traces
	    function captureLine() {
	        if (!hasStacks) {
	            return;
	        }

	        try {
	            throw new Error();
	        } catch (e) {
	            var lines = e.stack.split("\n");
	            var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
	            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
	            if (!fileNameAndLineNumber) {
	                return;
	            }

	            qFileName = fileNameAndLineNumber[0];
	            return fileNameAndLineNumber[1];
	        }
	    }

	    function deprecate(callback, name, alternative) {
	        return function () {
	            if (typeof console !== "undefined" && typeof console.warn === "function") {
	                console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
	            }
	            return callback.apply(callback, arguments);
	        };
	    }

	    // end of shims
	    // beginning of real work

	    /**
	     * Constructs a promise for an immediate reference, passes promises through, or
	     * coerces promises from different systems.
	     * @param value immediate reference or promise
	     */
	    function Q(value) {
	        // If the object is already a Promise, return it directly.  This enables
	        // the resolve function to both be used to created references from objects,
	        // but to tolerably coerce non-promises to promises.
	        if (value instanceof Promise) {
	            return value;
	        }

	        // assimilate thenables
	        if (isPromiseAlike(value)) {
	            return coerce(value);
	        } else {
	            return fulfill(value);
	        }
	    }
	    Q.resolve = Q;

	    /**
	     * Performs a task in a future turn of the event loop.
	     * @param {Function} task
	     */
	    Q.nextTick = nextTick;

	    /**
	     * Controls whether or not long stack traces will be on
	     */
	    Q.longStackSupport = false;

	    // enable long stacks if Q_DEBUG is set
	    if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process && process.env && process.env.Q_DEBUG) {
	        Q.longStackSupport = true;
	    }

	    /**
	     * Constructs a {promise, resolve, reject} object.
	     *
	     * `resolve` is a callback to invoke with a more resolved value for the
	     * promise. To fulfill the promise, invoke `resolve` with any value that is
	     * not a thenable. To reject the promise, invoke `resolve` with a rejected
	     * thenable, or invoke `reject` with the reason directly. To resolve the
	     * promise to another thenable, thus putting it in the same state, invoke
	     * `resolve` with that other thenable.
	     */
	    Q.defer = defer;
	    function defer() {
	        // if "messages" is an "Array", that indicates that the promise has not yet
	        // been resolved.  If it is "undefined", it has been resolved.  Each
	        // element of the messages array is itself an array of complete arguments to
	        // forward to the resolved promise.  We coerce the resolution value to a
	        // promise using the `resolve` function because it handles both fully
	        // non-thenable values and other thenables gracefully.
	        var messages = [],
	            progressListeners = [],
	            resolvedPromise;

	        var deferred = object_create(defer.prototype);
	        var promise = object_create(Promise.prototype);

	        promise.promiseDispatch = function (resolve, op, operands) {
	            var args = array_slice(arguments);
	            if (messages) {
	                messages.push(args);
	                if (op === "when" && operands[1]) {
	                    // progress operand
	                    progressListeners.push(operands[1]);
	                }
	            } else {
	                Q.nextTick(function () {
	                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
	                });
	            }
	        };

	        // XXX deprecated
	        promise.valueOf = function () {
	            if (messages) {
	                return promise;
	            }
	            var nearerValue = nearer(resolvedPromise);
	            if (isPromise(nearerValue)) {
	                resolvedPromise = nearerValue; // shorten chain
	            }
	            return nearerValue;
	        };

	        promise.inspect = function () {
	            if (!resolvedPromise) {
	                return { state: "pending" };
	            }
	            return resolvedPromise.inspect();
	        };

	        if (Q.longStackSupport && hasStacks) {
	            try {
	                throw new Error();
	            } catch (e) {
	                // NOTE: don't try to use `Error.captureStackTrace` or transfer the
	                // accessor around; that causes memory leaks as per GH-111. Just
	                // reify the stack trace as a string ASAP.
	                //
	                // At the same time, cut off the first line; it's always just
	                // "[object Promise]\n", as per the `toString`.
	                promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
	            }
	        }

	        // NOTE: we do the checks for `resolvedPromise` in each method, instead of
	        // consolidating them into `become`, since otherwise we'd create new
	        // promises with the lines `become(whatever(value))`. See e.g. GH-252.

	        function become(newPromise) {
	            resolvedPromise = newPromise;
	            promise.source = newPromise;

	            array_reduce(messages, function (undefined, message) {
	                Q.nextTick(function () {
	                    newPromise.promiseDispatch.apply(newPromise, message);
	                });
	            }, void 0);

	            messages = void 0;
	            progressListeners = void 0;
	        }

	        deferred.promise = promise;
	        deferred.resolve = function (value) {
	            if (resolvedPromise) {
	                return;
	            }

	            become(Q(value));
	        };

	        deferred.fulfill = function (value) {
	            if (resolvedPromise) {
	                return;
	            }

	            become(fulfill(value));
	        };
	        deferred.reject = function (reason) {
	            if (resolvedPromise) {
	                return;
	            }

	            become(reject(reason));
	        };
	        deferred.notify = function (progress) {
	            if (resolvedPromise) {
	                return;
	            }

	            array_reduce(progressListeners, function (undefined, progressListener) {
	                Q.nextTick(function () {
	                    progressListener(progress);
	                });
	            }, void 0);
	        };

	        return deferred;
	    }

	    /**
	     * Creates a Node-style callback that will resolve or reject the deferred
	     * promise.
	     * @returns a nodeback
	     */
	    defer.prototype.makeNodeResolver = function () {
	        var self = this;
	        return function (error, value) {
	            if (error) {
	                self.reject(error);
	            } else if (arguments.length > 2) {
	                self.resolve(array_slice(arguments, 1));
	            } else {
	                self.resolve(value);
	            }
	        };
	    };

	    /**
	     * @param resolver {Function} a function that returns nothing and accepts
	     * the resolve, reject, and notify functions for a deferred.
	     * @returns a promise that may be resolved with the given resolve and reject
	     * functions, or rejected by a thrown exception in resolver
	     */
	    Q.Promise = promise; // ES6
	    Q.promise = promise;
	    function promise(resolver) {
	        if (typeof resolver !== "function") {
	            throw new TypeError("resolver must be a function.");
	        }
	        var deferred = defer();
	        try {
	            resolver(deferred.resolve, deferred.reject, deferred.notify);
	        } catch (reason) {
	            deferred.reject(reason);
	        }
	        return deferred.promise;
	    }

	    promise.race = race; // ES6
	    promise.all = all; // ES6
	    promise.reject = reject; // ES6
	    promise.resolve = Q; // ES6

	    // XXX experimental.  This method is a way to denote that a local value is
	    // serializable and should be immediately dispatched to a remote upon request,
	    // instead of passing a reference.
	    Q.passByCopy = function (object) {
	        //freeze(object);
	        //passByCopies.set(object, true);
	        return object;
	    };

	    Promise.prototype.passByCopy = function () {
	        //freeze(object);
	        //passByCopies.set(object, true);
	        return this;
	    };

	    /**
	     * If two promises eventually fulfill to the same value, promises that value,
	     * but otherwise rejects.
	     * @param x {Any*}
	     * @param y {Any*}
	     * @returns {Any*} a promise for x and y if they are the same, but a rejection
	     * otherwise.
	     *
	     */
	    Q.join = function (x, y) {
	        return Q(x).join(y);
	    };

	    Promise.prototype.join = function (that) {
	        return Q([this, that]).spread(function (x, y) {
	            if (x === y) {
	                // TODO: "===" should be Object.is or equiv
	                return x;
	            } else {
	                throw new Error("Can't join: not the same: " + x + " " + y);
	            }
	        });
	    };

	    /**
	     * Returns a promise for the first of an array of promises to become settled.
	     * @param answers {Array[Any*]} promises to race
	     * @returns {Any*} the first promise to be settled
	     */
	    Q.race = race;
	    function race(answerPs) {
	        return promise(function (resolve, reject) {
	            // Switch to this once we can assume at least ES5
	            // answerPs.forEach(function (answerP) {
	            //     Q(answerP).then(resolve, reject);
	            // });
	            // Use this in the meantime
	            for (var i = 0, len = answerPs.length; i < len; i++) {
	                Q(answerPs[i]).then(resolve, reject);
	            }
	        });
	    }

	    Promise.prototype.race = function () {
	        return this.then(Q.race);
	    };

	    /**
	     * Constructs a Promise with a promise descriptor object and optional fallback
	     * function.  The descriptor contains methods like when(rejected), get(name),
	     * set(name, value), post(name, args), and delete(name), which all
	     * return either a value, a promise for a value, or a rejection.  The fallback
	     * accepts the operation name, a resolver, and any further arguments that would
	     * have been forwarded to the appropriate method above had a method been
	     * provided with the proper name.  The API makes no guarantees about the nature
	     * of the returned object, apart from that it is usable whereever promises are
	     * bought and sold.
	     */
	    Q.makePromise = Promise;
	    function Promise(descriptor, fallback, inspect) {
	        if (fallback === void 0) {
	            fallback = function fallback(op) {
	                return reject(new Error("Promise does not support operation: " + op));
	            };
	        }
	        if (inspect === void 0) {
	            inspect = function inspect() {
	                return { state: "unknown" };
	            };
	        }

	        var promise = object_create(Promise.prototype);

	        promise.promiseDispatch = function (resolve, op, args) {
	            var result;
	            try {
	                if (descriptor[op]) {
	                    result = descriptor[op].apply(promise, args);
	                } else {
	                    result = fallback.call(promise, op, args);
	                }
	            } catch (exception) {
	                result = reject(exception);
	            }
	            if (resolve) {
	                resolve(result);
	            }
	        };

	        promise.inspect = inspect;

	        // XXX deprecated `valueOf` and `exception` support
	        if (inspect) {
	            var inspected = inspect();
	            if (inspected.state === "rejected") {
	                promise.exception = inspected.reason;
	            }

	            promise.valueOf = function () {
	                var inspected = inspect();
	                if (inspected.state === "pending" || inspected.state === "rejected") {
	                    return promise;
	                }
	                return inspected.value;
	            };
	        }

	        return promise;
	    }

	    Promise.prototype.toString = function () {
	        return "[object Promise]";
	    };

	    Promise.prototype.then = function (fulfilled, rejected, progressed) {
	        var self = this;
	        var deferred = defer();
	        var done = false; // ensure the untrusted promise makes at most a
	        // single call to one of the callbacks

	        function _fulfilled(value) {
	            try {
	                return typeof fulfilled === "function" ? fulfilled(value) : value;
	            } catch (exception) {
	                return reject(exception);
	            }
	        }

	        function _rejected(exception) {
	            if (typeof rejected === "function") {
	                makeStackTraceLong(exception, self);
	                try {
	                    return rejected(exception);
	                } catch (newException) {
	                    return reject(newException);
	                }
	            }
	            return reject(exception);
	        }

	        function _progressed(value) {
	            return typeof progressed === "function" ? progressed(value) : value;
	        }

	        Q.nextTick(function () {
	            self.promiseDispatch(function (value) {
	                if (done) {
	                    return;
	                }
	                done = true;

	                deferred.resolve(_fulfilled(value));
	            }, "when", [function (exception) {
	                if (done) {
	                    return;
	                }
	                done = true;

	                deferred.resolve(_rejected(exception));
	            }]);
	        });

	        // Progress propagator need to be attached in the current tick.
	        self.promiseDispatch(void 0, "when", [void 0, function (value) {
	            var newValue;
	            var threw = false;
	            try {
	                newValue = _progressed(value);
	            } catch (e) {
	                threw = true;
	                if (Q.onerror) {
	                    Q.onerror(e);
	                } else {
	                    throw e;
	                }
	            }

	            if (!threw) {
	                deferred.notify(newValue);
	            }
	        }]);

	        return deferred.promise;
	    };

	    Q.tap = function (promise, callback) {
	        return Q(promise).tap(callback);
	    };

	    /**
	     * Works almost like "finally", but not called for rejections.
	     * Original resolution value is passed through callback unaffected.
	     * Callback may return a promise that will be awaited for.
	     * @param {Function} callback
	     * @returns {Q.Promise}
	     * @example
	     * doSomething()
	     *   .then(...)
	     *   .tap(console.log)
	     *   .then(...);
	     */
	    Promise.prototype.tap = function (callback) {
	        callback = Q(callback);

	        return this.then(function (value) {
	            return callback.fcall(value).thenResolve(value);
	        });
	    };

	    /**
	     * Registers an observer on a promise.
	     *
	     * Guarantees:
	     *
	     * 1. that fulfilled and rejected will be called only once.
	     * 2. that either the fulfilled callback or the rejected callback will be
	     *    called, but not both.
	     * 3. that fulfilled and rejected will not be called in this turn.
	     *
	     * @param value      promise or immediate reference to observe
	     * @param fulfilled  function to be called with the fulfilled value
	     * @param rejected   function to be called with the rejection exception
	     * @param progressed function to be called on any progress notifications
	     * @return promise for the return value from the invoked callback
	     */
	    Q.when = when;
	    function when(value, fulfilled, rejected, progressed) {
	        return Q(value).then(fulfilled, rejected, progressed);
	    }

	    Promise.prototype.thenResolve = function (value) {
	        return this.then(function () {
	            return value;
	        });
	    };

	    Q.thenResolve = function (promise, value) {
	        return Q(promise).thenResolve(value);
	    };

	    Promise.prototype.thenReject = function (reason) {
	        return this.then(function () {
	            throw reason;
	        });
	    };

	    Q.thenReject = function (promise, reason) {
	        return Q(promise).thenReject(reason);
	    };

	    /**
	     * If an object is not a promise, it is as "near" as possible.
	     * If a promise is rejected, it is as "near" as possible too.
	     * If its a fulfilled promise, the fulfillment value is nearer.
	     * If its a deferred promise and the deferred has been resolved, the
	     * resolution is "nearer".
	     * @param object
	     * @returns most resolved (nearest) form of the object
	     */

	    // XXX should we re-do this?
	    Q.nearer = nearer;
	    function nearer(value) {
	        if (isPromise(value)) {
	            var inspected = value.inspect();
	            if (inspected.state === "fulfilled") {
	                return inspected.value;
	            }
	        }
	        return value;
	    }

	    /**
	     * @returns whether the given object is a promise.
	     * Otherwise it is a fulfilled value.
	     */
	    Q.isPromise = isPromise;
	    function isPromise(object) {
	        return object instanceof Promise;
	    }

	    Q.isPromiseAlike = isPromiseAlike;
	    function isPromiseAlike(object) {
	        return isObject(object) && typeof object.then === "function";
	    }

	    /**
	     * @returns whether the given object is a pending promise, meaning not
	     * fulfilled or rejected.
	     */
	    Q.isPending = isPending;
	    function isPending(object) {
	        return isPromise(object) && object.inspect().state === "pending";
	    }

	    Promise.prototype.isPending = function () {
	        return this.inspect().state === "pending";
	    };

	    /**
	     * @returns whether the given object is a value or fulfilled
	     * promise.
	     */
	    Q.isFulfilled = isFulfilled;
	    function isFulfilled(object) {
	        return !isPromise(object) || object.inspect().state === "fulfilled";
	    }

	    Promise.prototype.isFulfilled = function () {
	        return this.inspect().state === "fulfilled";
	    };

	    /**
	     * @returns whether the given object is a rejected promise.
	     */
	    Q.isRejected = isRejected;
	    function isRejected(object) {
	        return isPromise(object) && object.inspect().state === "rejected";
	    }

	    Promise.prototype.isRejected = function () {
	        return this.inspect().state === "rejected";
	    };

	    //// BEGIN UNHANDLED REJECTION TRACKING

	    // This promise library consumes exceptions thrown in handlers so they can be
	    // handled by a subsequent promise.  The exceptions get added to this array when
	    // they are created, and removed when they are handled.  Note that in ES6 or
	    // shimmed environments, this would naturally be a `Set`.
	    var unhandledReasons = [];
	    var unhandledRejections = [];
	    var reportedUnhandledRejections = [];
	    var trackUnhandledRejections = true;

	    function resetUnhandledRejections() {
	        unhandledReasons.length = 0;
	        unhandledRejections.length = 0;

	        if (!trackUnhandledRejections) {
	            trackUnhandledRejections = true;
	        }
	    }

	    function trackRejection(promise, reason) {
	        if (!trackUnhandledRejections) {
	            return;
	        }
	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && typeof process.emit === "function") {
	            Q.nextTick.runAfter(function () {
	                if (array_indexOf(unhandledRejections, promise) !== -1) {
	                    process.emit("unhandledRejection", reason, promise);
	                    reportedUnhandledRejections.push(promise);
	                }
	            });
	        }

	        unhandledRejections.push(promise);
	        if (reason && typeof reason.stack !== "undefined") {
	            unhandledReasons.push(reason.stack);
	        } else {
	            unhandledReasons.push("(no stack) " + reason);
	        }
	    }

	    function untrackRejection(promise) {
	        if (!trackUnhandledRejections) {
	            return;
	        }

	        var at = array_indexOf(unhandledRejections, promise);
	        if (at !== -1) {
	            if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && typeof process.emit === "function") {
	                Q.nextTick.runAfter(function () {
	                    var atReport = array_indexOf(reportedUnhandledRejections, promise);
	                    if (atReport !== -1) {
	                        process.emit("rejectionHandled", unhandledReasons[at], promise);
	                        reportedUnhandledRejections.splice(atReport, 1);
	                    }
	                });
	            }
	            unhandledRejections.splice(at, 1);
	            unhandledReasons.splice(at, 1);
	        }
	    }

	    Q.resetUnhandledRejections = resetUnhandledRejections;

	    Q.getUnhandledReasons = function () {
	        // Make a copy so that consumers can't interfere with our internal state.
	        return unhandledReasons.slice();
	    };

	    Q.stopUnhandledRejectionTracking = function () {
	        resetUnhandledRejections();
	        trackUnhandledRejections = false;
	    };

	    resetUnhandledRejections();

	    //// END UNHANDLED REJECTION TRACKING

	    /**
	     * Constructs a rejected promise.
	     * @param reason value describing the failure
	     */
	    Q.reject = reject;
	    function reject(reason) {
	        var rejection = Promise({
	            "when": function when(rejected) {
	                // note that the error has been handled
	                if (rejected) {
	                    untrackRejection(this);
	                }
	                return rejected ? rejected(reason) : this;
	            }
	        }, function fallback() {
	            return this;
	        }, function inspect() {
	            return { state: "rejected", reason: reason };
	        });

	        // Note that the reason has not been handled.
	        trackRejection(rejection, reason);

	        return rejection;
	    }

	    /**
	     * Constructs a fulfilled promise for an immediate reference.
	     * @param value immediate reference
	     */
	    Q.fulfill = fulfill;
	    function fulfill(value) {
	        return Promise({
	            "when": function when() {
	                return value;
	            },
	            "get": function get(name) {
	                return value[name];
	            },
	            "set": function set(name, rhs) {
	                value[name] = rhs;
	            },
	            "delete": function _delete(name) {
	                delete value[name];
	            },
	            "post": function post(name, args) {
	                // Mark Miller proposes that post with no name should apply a
	                // promised function.
	                if (name === null || name === void 0) {
	                    return value.apply(void 0, args);
	                } else {
	                    return value[name].apply(value, args);
	                }
	            },
	            "apply": function apply(thisp, args) {
	                return value.apply(thisp, args);
	            },
	            "keys": function keys() {
	                return object_keys(value);
	            }
	        }, void 0, function inspect() {
	            return { state: "fulfilled", value: value };
	        });
	    }

	    /**
	     * Converts thenables to Q promises.
	     * @param promise thenable promise
	     * @returns a Q promise
	     */
	    function coerce(promise) {
	        var deferred = defer();
	        Q.nextTick(function () {
	            try {
	                promise.then(deferred.resolve, deferred.reject, deferred.notify);
	            } catch (exception) {
	                deferred.reject(exception);
	            }
	        });
	        return deferred.promise;
	    }

	    /**
	     * Annotates an object such that it will never be
	     * transferred away from this process over any promise
	     * communication channel.
	     * @param object
	     * @returns promise a wrapping of that object that
	     * additionally responds to the "isDef" message
	     * without a rejection.
	     */
	    Q.master = master;
	    function master(object) {
	        return Promise({
	            "isDef": function isDef() {}
	        }, function fallback(op, args) {
	            return dispatch(object, op, args);
	        }, function () {
	            return Q(object).inspect();
	        });
	    }

	    /**
	     * Spreads the values of a promised array of arguments into the
	     * fulfillment callback.
	     * @param fulfilled callback that receives variadic arguments from the
	     * promised array
	     * @param rejected callback that receives the exception if the promise
	     * is rejected.
	     * @returns a promise for the return value or thrown exception of
	     * either callback.
	     */
	    Q.spread = spread;
	    function spread(value, fulfilled, rejected) {
	        return Q(value).spread(fulfilled, rejected);
	    }

	    Promise.prototype.spread = function (fulfilled, rejected) {
	        return this.all().then(function (array) {
	            return fulfilled.apply(void 0, array);
	        }, rejected);
	    };

	    /**
	     * The async function is a decorator for generator functions, turning
	     * them into asynchronous generators.  Although generators are only part
	     * of the newest ECMAScript 6 drafts, this code does not cause syntax
	     * errors in older engines.  This code should continue to work and will
	     * in fact improve over time as the language improves.
	     *
	     * ES6 generators are currently part of V8 version 3.19 with the
	     * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
	     * for longer, but under an older Python-inspired form.  This function
	     * works on both kinds of generators.
	     *
	     * Decorates a generator function such that:
	     *  - it may yield promises
	     *  - execution will continue when that promise is fulfilled
	     *  - the value of the yield expression will be the fulfilled value
	     *  - it returns a promise for the return value (when the generator
	     *    stops iterating)
	     *  - the decorated function returns a promise for the return value
	     *    of the generator or the first rejected promise among those
	     *    yielded.
	     *  - if an error is thrown in the generator, it propagates through
	     *    every following yield until it is caught, or until it escapes
	     *    the generator function altogether, and is translated into a
	     *    rejection for the promise returned by the decorated generator.
	     */
	    Q.async = async;
	    function async(makeGenerator) {
	        return function () {
	            // when verb is "send", arg is a value
	            // when verb is "throw", arg is an exception
	            function continuer(verb, arg) {
	                var result;

	                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
	                // engine that has a deployed base of browsers that support generators.
	                // However, SM's generators use the Python-inspired semantics of
	                // outdated ES6 drafts.  We would like to support ES6, but we'd also
	                // like to make it possible to use generators in deployed browsers, so
	                // we also support Python-style generators.  At some point we can remove
	                // this block.

	                if (typeof StopIteration === "undefined") {
	                    // ES6 Generators
	                    try {
	                        result = generator[verb](arg);
	                    } catch (exception) {
	                        return reject(exception);
	                    }
	                    if (result.done) {
	                        return Q(result.value);
	                    } else {
	                        return when(result.value, callback, errback);
	                    }
	                } else {
	                    // SpiderMonkey Generators
	                    // FIXME: Remove this case when SM does ES6 generators.
	                    try {
	                        result = generator[verb](arg);
	                    } catch (exception) {
	                        if (isStopIteration(exception)) {
	                            return Q(exception.value);
	                        } else {
	                            return reject(exception);
	                        }
	                    }
	                    return when(result, callback, errback);
	                }
	            }
	            var generator = makeGenerator.apply(this, arguments);
	            var callback = continuer.bind(continuer, "next");
	            var errback = continuer.bind(continuer, "throw");
	            return callback();
	        };
	    }

	    /**
	     * The spawn function is a small wrapper around async that immediately
	     * calls the generator and also ends the promise chain, so that any
	     * unhandled errors are thrown instead of forwarded to the error
	     * handler. This is useful because it's extremely common to run
	     * generators at the top-level to work with libraries.
	     */
	    Q.spawn = spawn;
	    function spawn(makeGenerator) {
	        Q.done(Q.async(makeGenerator)());
	    }

	    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
	    /**
	     * Throws a ReturnValue exception to stop an asynchronous generator.
	     *
	     * This interface is a stop-gap measure to support generator return
	     * values in older Firefox/SpiderMonkey.  In browsers that support ES6
	     * generators like Chromium 29, just use "return" in your generator
	     * functions.
	     *
	     * @param value the return value for the surrounding generator
	     * @throws ReturnValue exception with the value.
	     * @example
	     * // ES6 style
	     * Q.async(function* () {
	     *      var foo = yield getFooPromise();
	     *      var bar = yield getBarPromise();
	     *      return foo + bar;
	     * })
	     * // Older SpiderMonkey style
	     * Q.async(function () {
	     *      var foo = yield getFooPromise();
	     *      var bar = yield getBarPromise();
	     *      Q.return(foo + bar);
	     * })
	     */
	    Q["return"] = _return;
	    function _return(value) {
	        throw new QReturnValue(value);
	    }

	    /**
	     * The promised function decorator ensures that any promise arguments
	     * are settled and passed as values (`this` is also settled and passed
	     * as a value).  It will also ensure that the result of a function is
	     * always a promise.
	     *
	     * @example
	     * var add = Q.promised(function (a, b) {
	     *     return a + b;
	     * });
	     * add(Q(a), Q(B));
	     *
	     * @param {function} callback The function to decorate
	     * @returns {function} a function that has been decorated.
	     */
	    Q.promised = promised;
	    function promised(callback) {
	        return function () {
	            return spread([this, all(arguments)], function (self, args) {
	                return callback.apply(self, args);
	            });
	        };
	    }

	    /**
	     * sends a message to a value in a future turn
	     * @param object* the recipient
	     * @param op the name of the message operation, e.g., "when",
	     * @param args further arguments to be forwarded to the operation
	     * @returns result {Promise} a promise for the result of the operation
	     */
	    Q.dispatch = dispatch;
	    function dispatch(object, op, args) {
	        return Q(object).dispatch(op, args);
	    }

	    Promise.prototype.dispatch = function (op, args) {
	        var self = this;
	        var deferred = defer();
	        Q.nextTick(function () {
	            self.promiseDispatch(deferred.resolve, op, args);
	        });
	        return deferred.promise;
	    };

	    /**
	     * Gets the value of a property in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of property to get
	     * @return promise for the property value
	     */
	    Q.get = function (object, key) {
	        return Q(object).dispatch("get", [key]);
	    };

	    Promise.prototype.get = function (key) {
	        return this.dispatch("get", [key]);
	    };

	    /**
	     * Sets the value of a property in a future turn.
	     * @param object    promise or immediate reference for object object
	     * @param name      name of property to set
	     * @param value     new value of property
	     * @return promise for the return value
	     */
	    Q.set = function (object, key, value) {
	        return Q(object).dispatch("set", [key, value]);
	    };

	    Promise.prototype.set = function (key, value) {
	        return this.dispatch("set", [key, value]);
	    };

	    /**
	     * Deletes a property in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of property to delete
	     * @return promise for the return value
	     */
	    Q.del = // XXX legacy
	    Q["delete"] = function (object, key) {
	        return Q(object).dispatch("delete", [key]);
	    };

	    Promise.prototype.del = // XXX legacy
	    Promise.prototype["delete"] = function (key) {
	        return this.dispatch("delete", [key]);
	    };

	    /**
	     * Invokes a method in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of method to invoke
	     * @param value     a value to post, typically an array of
	     *                  invocation arguments for promises that
	     *                  are ultimately backed with `resolve` values,
	     *                  as opposed to those backed with URLs
	     *                  wherein the posted value can be any
	     *                  JSON serializable object.
	     * @return promise for the return value
	     */
	    // bound locally because it is used by other methods
	    Q.mapply = // XXX As proposed by "Redsandro"
	    Q.post = function (object, name, args) {
	        return Q(object).dispatch("post", [name, args]);
	    };

	    Promise.prototype.mapply = // XXX As proposed by "Redsandro"
	    Promise.prototype.post = function (name, args) {
	        return this.dispatch("post", [name, args]);
	    };

	    /**
	     * Invokes a method in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @param name      name of method to invoke
	     * @param ...args   array of invocation arguments
	     * @return promise for the return value
	     */
	    Q.send = // XXX Mark Miller's proposed parlance
	    Q.mcall = // XXX As proposed by "Redsandro"
	    Q.invoke = function (object, name /*...args*/) {
	        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
	    };

	    Promise.prototype.send = // XXX Mark Miller's proposed parlance
	    Promise.prototype.mcall = // XXX As proposed by "Redsandro"
	    Promise.prototype.invoke = function (name /*...args*/) {
	        return this.dispatch("post", [name, array_slice(arguments, 1)]);
	    };

	    /**
	     * Applies the promised function in a future turn.
	     * @param object    promise or immediate reference for target function
	     * @param args      array of application arguments
	     */
	    Q.fapply = function (object, args) {
	        return Q(object).dispatch("apply", [void 0, args]);
	    };

	    Promise.prototype.fapply = function (args) {
	        return this.dispatch("apply", [void 0, args]);
	    };

	    /**
	     * Calls the promised function in a future turn.
	     * @param object    promise or immediate reference for target function
	     * @param ...args   array of application arguments
	     */
	    Q["try"] = Q.fcall = function (object /* ...args*/) {
	        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
	    };

	    Promise.prototype.fcall = function () /*...args*/{
	        return this.dispatch("apply", [void 0, array_slice(arguments)]);
	    };

	    /**
	     * Binds the promised function, transforming return values into a fulfilled
	     * promise and thrown errors into a rejected one.
	     * @param object    promise or immediate reference for target function
	     * @param ...args   array of application arguments
	     */
	    Q.fbind = function (object /*...args*/) {
	        var promise = Q(object);
	        var args = array_slice(arguments, 1);
	        return function fbound() {
	            return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
	        };
	    };
	    Promise.prototype.fbind = function () /*...args*/{
	        var promise = this;
	        var args = array_slice(arguments);
	        return function fbound() {
	            return promise.dispatch("apply", [this, args.concat(array_slice(arguments))]);
	        };
	    };

	    /**
	     * Requests the names of the owned properties of a promised
	     * object in a future turn.
	     * @param object    promise or immediate reference for target object
	     * @return promise for the keys of the eventually settled object
	     */
	    Q.keys = function (object) {
	        return Q(object).dispatch("keys", []);
	    };

	    Promise.prototype.keys = function () {
	        return this.dispatch("keys", []);
	    };

	    /**
	     * Turns an array of promises into a promise for an array.  If any of
	     * the promises gets rejected, the whole array is rejected immediately.
	     * @param {Array*} an array (or promise for an array) of values (or
	     * promises for values)
	     * @returns a promise for an array of the corresponding values
	     */
	    // By Mark Miller
	    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
	    Q.all = all;
	    function all(promises) {
	        return when(promises, function (promises) {
	            var pendingCount = 0;
	            var deferred = defer();
	            array_reduce(promises, function (undefined, promise, index) {
	                var snapshot;
	                if (isPromise(promise) && (snapshot = promise.inspect()).state === "fulfilled") {
	                    promises[index] = snapshot.value;
	                } else {
	                    ++pendingCount;
	                    when(promise, function (value) {
	                        promises[index] = value;
	                        if (--pendingCount === 0) {
	                            deferred.resolve(promises);
	                        }
	                    }, deferred.reject, function (progress) {
	                        deferred.notify({ index: index, value: progress });
	                    });
	                }
	            }, void 0);
	            if (pendingCount === 0) {
	                deferred.resolve(promises);
	            }
	            return deferred.promise;
	        });
	    }

	    Promise.prototype.all = function () {
	        return all(this);
	    };

	    /**
	     * Returns the first resolved promise of an array. Prior rejected promises are
	     * ignored.  Rejects only if all promises are rejected.
	     * @param {Array*} an array containing values or promises for values
	     * @returns a promise fulfilled with the value of the first resolved promise,
	     * or a rejected promise if all promises are rejected.
	     */
	    Q.any = any;

	    function any(promises) {
	        if (promises.length === 0) {
	            return Q.resolve();
	        }

	        var deferred = Q.defer();
	        var pendingCount = 0;
	        array_reduce(promises, function (prev, current, index) {
	            var promise = promises[index];

	            pendingCount++;

	            when(promise, onFulfilled, onRejected, onProgress);
	            function onFulfilled(result) {
	                deferred.resolve(result);
	            }
	            function onRejected() {
	                pendingCount--;
	                if (pendingCount === 0) {
	                    deferred.reject(new Error("Can't get fulfillment value from any promise, all " + "promises were rejected."));
	                }
	            }
	            function onProgress(progress) {
	                deferred.notify({
	                    index: index,
	                    value: progress
	                });
	            }
	        }, undefined);

	        return deferred.promise;
	    }

	    Promise.prototype.any = function () {
	        return any(this);
	    };

	    /**
	     * Waits for all promises to be settled, either fulfilled or
	     * rejected.  This is distinct from `all` since that would stop
	     * waiting at the first rejection.  The promise returned by
	     * `allResolved` will never be rejected.
	     * @param promises a promise for an array (or an array) of promises
	     * (or values)
	     * @return a promise for an array of promises
	     */
	    Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
	    function allResolved(promises) {
	        return when(promises, function (promises) {
	            promises = array_map(promises, Q);
	            return when(all(array_map(promises, function (promise) {
	                return when(promise, noop, noop);
	            })), function () {
	                return promises;
	            });
	        });
	    }

	    Promise.prototype.allResolved = function () {
	        return allResolved(this);
	    };

	    /**
	     * @see Promise#allSettled
	     */
	    Q.allSettled = allSettled;
	    function allSettled(promises) {
	        return Q(promises).allSettled();
	    }

	    /**
	     * Turns an array of promises into a promise for an array of their states (as
	     * returned by `inspect`) when they have all settled.
	     * @param {Array[Any*]} values an array (or promise for an array) of values (or
	     * promises for values)
	     * @returns {Array[State]} an array of states for the respective values.
	     */
	    Promise.prototype.allSettled = function () {
	        return this.then(function (promises) {
	            return all(array_map(promises, function (promise) {
	                promise = Q(promise);
	                function regardless() {
	                    return promise.inspect();
	                }
	                return promise.then(regardless, regardless);
	            }));
	        });
	    };

	    /**
	     * Captures the failure of a promise, giving an oportunity to recover
	     * with a callback.  If the given promise is fulfilled, the returned
	     * promise is fulfilled.
	     * @param {Any*} promise for something
	     * @param {Function} callback to fulfill the returned promise if the
	     * given promise is rejected
	     * @returns a promise for the return value of the callback
	     */
	    Q.fail = // XXX legacy
	    Q["catch"] = function (object, rejected) {
	        return Q(object).then(void 0, rejected);
	    };

	    Promise.prototype.fail = // XXX legacy
	    Promise.prototype["catch"] = function (rejected) {
	        return this.then(void 0, rejected);
	    };

	    /**
	     * Attaches a listener that can respond to progress notifications from a
	     * promise's originating deferred. This listener receives the exact arguments
	     * passed to ``deferred.notify``.
	     * @param {Any*} promise for something
	     * @param {Function} callback to receive any progress notifications
	     * @returns the given promise, unchanged
	     */
	    Q.progress = progress;
	    function progress(object, progressed) {
	        return Q(object).then(void 0, void 0, progressed);
	    }

	    Promise.prototype.progress = function (progressed) {
	        return this.then(void 0, void 0, progressed);
	    };

	    /**
	     * Provides an opportunity to observe the settling of a promise,
	     * regardless of whether the promise is fulfilled or rejected.  Forwards
	     * the resolution to the returned promise when the callback is done.
	     * The callback can return a promise to defer completion.
	     * @param {Any*} promise
	     * @param {Function} callback to observe the resolution of the given
	     * promise, takes no arguments.
	     * @returns a promise for the resolution of the given promise when
	     * ``fin`` is done.
	     */
	    Q.fin = // XXX legacy
	    Q["finally"] = function (object, callback) {
	        return Q(object)["finally"](callback);
	    };

	    Promise.prototype.fin = // XXX legacy
	    Promise.prototype["finally"] = function (callback) {
	        callback = Q(callback);
	        return this.then(function (value) {
	            return callback.fcall().then(function () {
	                return value;
	            });
	        }, function (reason) {
	            // TODO attempt to recycle the rejection with "this".
	            return callback.fcall().then(function () {
	                throw reason;
	            });
	        });
	    };

	    /**
	     * Terminates a chain of promises, forcing rejections to be
	     * thrown as exceptions.
	     * @param {Any*} promise at the end of a chain of promises
	     * @returns nothing
	     */
	    Q.done = function (object, fulfilled, rejected, progress) {
	        return Q(object).done(fulfilled, rejected, progress);
	    };

	    Promise.prototype.done = function (fulfilled, rejected, progress) {
	        var onUnhandledError = function onUnhandledError(error) {
	            // forward to a future turn so that ``when``
	            // does not catch it and turn it into a rejection.
	            Q.nextTick(function () {
	                makeStackTraceLong(error, promise);
	                if (Q.onerror) {
	                    Q.onerror(error);
	                } else {
	                    throw error;
	                }
	            });
	        };

	        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
	        var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;

	        if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process && process.domain) {
	            onUnhandledError = process.domain.bind(onUnhandledError);
	        }

	        promise.then(void 0, onUnhandledError);
	    };

	    /**
	     * Causes a promise to be rejected if it does not get fulfilled before
	     * some milliseconds time out.
	     * @param {Any*} promise
	     * @param {Number} milliseconds timeout
	     * @param {Any*} custom error message or Error object (optional)
	     * @returns a promise for the resolution of the given promise if it is
	     * fulfilled before the timeout, otherwise rejected.
	     */
	    Q.timeout = function (object, ms, error) {
	        return Q(object).timeout(ms, error);
	    };

	    Promise.prototype.timeout = function (ms, error) {
	        var deferred = defer();
	        var timeoutId = setTimeout(function () {
	            if (!error || "string" === typeof error) {
	                error = new Error(error || "Timed out after " + ms + " ms");
	                error.code = "ETIMEDOUT";
	            }
	            deferred.reject(error);
	        }, ms);

	        this.then(function (value) {
	            clearTimeout(timeoutId);
	            deferred.resolve(value);
	        }, function (exception) {
	            clearTimeout(timeoutId);
	            deferred.reject(exception);
	        }, deferred.notify);

	        return deferred.promise;
	    };

	    /**
	     * Returns a promise for the given value (or promised value), some
	     * milliseconds after it resolved. Passes rejections immediately.
	     * @param {Any*} promise
	     * @param {Number} milliseconds
	     * @returns a promise for the resolution of the given promise after milliseconds
	     * time has elapsed since the resolution of the given promise.
	     * If the given promise rejects, that is passed immediately.
	     */
	    Q.delay = function (object, timeout) {
	        if (timeout === void 0) {
	            timeout = object;
	            object = void 0;
	        }
	        return Q(object).delay(timeout);
	    };

	    Promise.prototype.delay = function (timeout) {
	        return this.then(function (value) {
	            var deferred = defer();
	            setTimeout(function () {
	                deferred.resolve(value);
	            }, timeout);
	            return deferred.promise;
	        });
	    };

	    /**
	     * Passes a continuation to a Node function, which is called with the given
	     * arguments provided as an array, and returns a promise.
	     *
	     *      Q.nfapply(FS.readFile, [__filename])
	     *      .then(function (content) {
	     *      })
	     *
	     */
	    Q.nfapply = function (callback, args) {
	        return Q(callback).nfapply(args);
	    };

	    Promise.prototype.nfapply = function (args) {
	        var deferred = defer();
	        var nodeArgs = array_slice(args);
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };

	    /**
	     * Passes a continuation to a Node function, which is called with the given
	     * arguments provided individually, and returns a promise.
	     * @example
	     * Q.nfcall(FS.readFile, __filename)
	     * .then(function (content) {
	     * })
	     *
	     */
	    Q.nfcall = function (callback /*...args*/) {
	        var args = array_slice(arguments, 1);
	        return Q(callback).nfapply(args);
	    };

	    Promise.prototype.nfcall = function () /*...args*/{
	        var nodeArgs = array_slice(arguments);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };

	    /**
	     * Wraps a NodeJS continuation passing function and returns an equivalent
	     * version that returns a promise.
	     * @example
	     * Q.nfbind(FS.readFile, __filename)("utf-8")
	     * .then(console.log)
	     * .done()
	     */
	    Q.nfbind = Q.denodeify = function (callback /*...args*/) {
	        var baseArgs = array_slice(arguments, 1);
	        return function () {
	            var nodeArgs = baseArgs.concat(array_slice(arguments));
	            var deferred = defer();
	            nodeArgs.push(deferred.makeNodeResolver());
	            Q(callback).fapply(nodeArgs).fail(deferred.reject);
	            return deferred.promise;
	        };
	    };

	    Promise.prototype.nfbind = Promise.prototype.denodeify = function () /*...args*/{
	        var args = array_slice(arguments);
	        args.unshift(this);
	        return Q.denodeify.apply(void 0, args);
	    };

	    Q.nbind = function (callback, thisp /*...args*/) {
	        var baseArgs = array_slice(arguments, 2);
	        return function () {
	            var nodeArgs = baseArgs.concat(array_slice(arguments));
	            var deferred = defer();
	            nodeArgs.push(deferred.makeNodeResolver());
	            function bound() {
	                return callback.apply(thisp, arguments);
	            }
	            Q(bound).fapply(nodeArgs).fail(deferred.reject);
	            return deferred.promise;
	        };
	    };

	    Promise.prototype.nbind = function () /*thisp, ...args*/{
	        var args = array_slice(arguments, 0);
	        args.unshift(this);
	        return Q.nbind.apply(void 0, args);
	    };

	    /**
	     * Calls a method of a Node-style object that accepts a Node-style
	     * callback with a given array of arguments, plus a provided callback.
	     * @param object an object that has the named method
	     * @param {String} name name of the method of object
	     * @param {Array} args arguments to pass to the method; the callback
	     * will be provided by Q and appended to these arguments.
	     * @returns a promise for the value or error
	     */
	    Q.nmapply = // XXX As proposed by "Redsandro"
	    Q.npost = function (object, name, args) {
	        return Q(object).npost(name, args);
	    };

	    Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
	    Promise.prototype.npost = function (name, args) {
	        var nodeArgs = array_slice(args || []);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };

	    /**
	     * Calls a method of a Node-style object that accepts a Node-style
	     * callback, forwarding the given variadic arguments, plus a provided
	     * callback argument.
	     * @param object an object that has the named method
	     * @param {String} name name of the method of object
	     * @param ...args arguments to pass to the method; the callback will
	     * be provided by Q and appended to these arguments.
	     * @returns a promise for the value or error
	     */
	    Q.nsend = // XXX Based on Mark Miller's proposed "send"
	    Q.nmcall = // XXX Based on "Redsandro's" proposal
	    Q.ninvoke = function (object, name /*...args*/) {
	        var nodeArgs = array_slice(arguments, 2);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };

	    Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
	    Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
	    Promise.prototype.ninvoke = function (name /*...args*/) {
	        var nodeArgs = array_slice(arguments, 1);
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	        return deferred.promise;
	    };

	    /**
	     * If a function would like to support both Node continuation-passing-style and
	     * promise-returning-style, it can end its internal promise chain with
	     * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
	     * elects to use a nodeback, the result will be sent there.  If they do not
	     * pass a nodeback, they will receive the result promise.
	     * @param object a result (or a promise for a result)
	     * @param {Function} nodeback a Node.js-style callback
	     * @returns either the promise or nothing
	     */
	    Q.nodeify = nodeify;
	    function nodeify(object, nodeback) {
	        return Q(object).nodeify(nodeback);
	    }

	    Promise.prototype.nodeify = function (nodeback) {
	        if (nodeback) {
	            this.then(function (value) {
	                Q.nextTick(function () {
	                    nodeback(null, value);
	                });
	            }, function (error) {
	                Q.nextTick(function () {
	                    nodeback(error);
	                });
	            });
	        } else {
	            return this;
	        }
	    };

	    Q.noConflict = function () {
	        throw new Error("Q.noConflict only works when Q is used as a global");
	    };

	    // All code before this point will be filtered from stack traces.
	    var qEndingLine = captureLine();

	    return Q;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(10).setImmediate, __webpack_require__(12)(module)))

/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (module) {
		if (!module.webpackPolyfill) {
			module.deprecate = function () {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */

	/**
	 * Promises/A+ and when() implementation
	 * when is part of the cujoJS family of libraries (http://cujojs.com/)
	 * @author Brian Cavalier
	 * @author John Hann
	 */
	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var timed = __webpack_require__(14);
			var array = __webpack_require__(19);
			var flow = __webpack_require__(22);
			var fold = __webpack_require__(23);
			var inspect = __webpack_require__(24);
			var generate = __webpack_require__(25);
			var progress = __webpack_require__(26);
			var withThis = __webpack_require__(27);
			var unhandledRejection = __webpack_require__(28);
			var TimeoutError = __webpack_require__(18);

			var Promise = [array, flow, fold, generate, progress, inspect, withThis, timed, unhandledRejection].reduce(function (Promise, feature) {
				return feature(Promise);
			}, __webpack_require__(30));

			var apply = __webpack_require__(21)(Promise);

			// Public API

			when.promise = promise; // Create a pending promise
			when.resolve = Promise.resolve; // Create a resolved promise
			when.reject = Promise.reject; // Create a rejected promise

			when.lift = lift; // lift a function to return promises
			when['try'] = attempt; // call a function and return a promise
			when.attempt = attempt; // alias for when.try

			when.iterate = Promise.iterate; // DEPRECATED (use cujojs/most streams) Generate a stream of promises
			when.unfold = Promise.unfold; // DEPRECATED (use cujojs/most streams) Generate a stream of promises

			when.join = join; // Join 2 or more promises

			when.all = all; // Resolve a list of promises
			when.settle = settle; // Settle a list of promises

			when.any = lift(Promise.any); // One-winner race
			when.some = lift(Promise.some); // Multi-winner race
			when.race = lift(Promise.race); // First-to-settle race

			when.map = map; // Array.map() for promises
			when.filter = filter; // Array.filter() for promises
			when.reduce = lift(Promise.reduce); // Array.reduce() for promises
			when.reduceRight = lift(Promise.reduceRight); // Array.reduceRight() for promises

			when.isPromiseLike = isPromiseLike; // Is something promise-like, aka thenable

			when.Promise = Promise; // Promise constructor
			when.defer = defer; // Create a {promise, resolve, reject} tuple

			// Error types

			when.TimeoutError = TimeoutError;

			/**
	   * Get a trusted promise for x, or by transforming x with onFulfilled
	   *
	   * @param {*} x
	   * @param {function?} onFulfilled callback to be called when x is
	   *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	   *   will be invoked immediately.
	   * @param {function?} onRejected callback to be called when x is
	   *   rejected.
	   * @param {function?} onProgress callback to be called when progress updates
	   *   are issued for x. @deprecated
	   * @returns {Promise} a new promise that will fulfill with the return
	   *   value of callback or errback or the completion value of promiseOrValue if
	   *   callback and/or errback is not supplied.
	   */
			function when(x, onFulfilled, onRejected, onProgress) {
				var p = Promise.resolve(x);
				if (arguments.length < 2) {
					return p;
				}

				return p.then(onFulfilled, onRejected, onProgress);
			}

			/**
	   * Creates a new promise whose fate is determined by resolver.
	   * @param {function} resolver function(resolve, reject, notify)
	   * @returns {Promise} promise whose fate is determine by resolver
	   */
			function promise(resolver) {
				return new Promise(resolver);
			}

			/**
	   * Lift the supplied function, creating a version of f that returns
	   * promises, and accepts promises as arguments.
	   * @param {function} f
	   * @returns {Function} version of f that returns promises
	   */
			function lift(f) {
				return function () {
					for (var i = 0, l = arguments.length, a = new Array(l); i < l; ++i) {
						a[i] = arguments[i];
					}
					return apply(f, this, a);
				};
			}

			/**
	   * Call f in a future turn, with the supplied args, and return a promise
	   * for the result.
	   * @param {function} f
	   * @returns {Promise}
	   */
			function attempt(f /*, args... */) {
				/*jshint validthis:true */
				for (var i = 0, l = arguments.length - 1, a = new Array(l); i < l; ++i) {
					a[i] = arguments[i + 1];
				}
				return apply(f, this, a);
			}

			/**
	   * Creates a {promise, resolver} pair, either or both of which
	   * may be given out safely to consumers.
	   * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
	   */
			function defer() {
				return new Deferred();
			}

			function Deferred() {
				var p = Promise._defer();

				function resolve(x) {
					p._handler.resolve(x);
				}
				function reject(x) {
					p._handler.reject(x);
				}
				function notify(x) {
					p._handler.notify(x);
				}

				this.promise = p;
				this.resolve = resolve;
				this.reject = reject;
				this.notify = notify;
				this.resolver = { resolve: resolve, reject: reject, notify: notify };
			}

			/**
	   * Determines if x is promise-like, i.e. a thenable object
	   * NOTE: Will return true for *any thenable object*, and isn't truly
	   * safe, since it may attempt to access the `then` property of x (i.e.
	   *  clever/malicious getters may do weird things)
	   * @param {*} x anything
	   * @returns {boolean} true if x is promise-like
	   */
			function isPromiseLike(x) {
				return x && typeof x.then === 'function';
			}

			/**
	   * Return a promise that will resolve only once all the supplied arguments
	   * have resolved. The resolution value of the returned promise will be an array
	   * containing the resolution values of each of the arguments.
	   * @param {...*} arguments may be a mix of promises and values
	   * @returns {Promise}
	   */
			function join() /* ...promises */{
				return Promise.all(arguments);
			}

			/**
	   * Return a promise that will fulfill once all input promises have
	   * fulfilled, or reject when any one input promise rejects.
	   * @param {array|Promise} promises array (or promise for an array) of promises
	   * @returns {Promise}
	   */
			function all(promises) {
				return when(promises, Promise.all);
			}

			/**
	   * Return a promise that will always fulfill with an array containing
	   * the outcome states of all input promises.  The returned promise
	   * will only reject if `promises` itself is a rejected promise.
	   * @param {array|Promise} promises array (or promise for an array) of promises
	   * @returns {Promise} promise for array of settled state descriptors
	   */
			function settle(promises) {
				return when(promises, Promise.settle);
			}

			/**
	   * Promise-aware array map function, similar to `Array.prototype.map()`,
	   * but input array may contain promises or values.
	   * @param {Array|Promise} promises array of anything, may contain promises and values
	   * @param {function(x:*, index:Number):*} mapFunc map function which may
	   *  return a promise or value
	   * @returns {Promise} promise that will fulfill with an array of mapped values
	   *  or reject if any input promise rejects.
	   */
			function map(promises, mapFunc) {
				return when(promises, function (promises) {
					return Promise.map(promises, mapFunc);
				});
			}

			/**
	   * Filter the provided array of promises using the provided predicate.  Input may
	   * contain promises and values
	   * @param {Array|Promise} promises array of promises and values
	   * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	   *  Must return truthy (or promise for truthy) for items to retain.
	   * @returns {Promise} promise that will fulfill with an array containing all items
	   *  for which predicate returned truthy.
	   */
			function filter(promises, predicate) {
				return when(promises, function (promises) {
					return Promise.filter(promises, predicate);
				});
			}

			return when;
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var env = __webpack_require__(15);
			var TimeoutError = __webpack_require__(18);

			function setTimeout(f, ms, x, y) {
				return env.setTimer(function () {
					f(x, y, ms);
				}, ms);
			}

			return function timed(Promise) {
				/**
	    * Return a new promise whose fulfillment value is revealed only
	    * after ms milliseconds
	    * @param {number} ms milliseconds
	    * @returns {Promise}
	    */
				Promise.prototype.delay = function (ms) {
					var p = this._beget();
					this._handler.fold(handleDelay, ms, void 0, p._handler);
					return p;
				};

				function handleDelay(ms, x, h) {
					setTimeout(resolveDelay, ms, x, h);
				}

				function resolveDelay(x, h) {
					h.resolve(x);
				}

				/**
	    * Return a new promise that rejects after ms milliseconds unless
	    * this promise fulfills earlier, in which case the returned promise
	    * fulfills with the same value.
	    * @param {number} ms milliseconds
	    * @param {Error|*=} reason optional rejection reason to use, defaults
	    *   to a TimeoutError if not provided
	    * @returns {Promise}
	    */
				Promise.prototype.timeout = function (ms, reason) {
					var p = this._beget();
					var h = p._handler;

					var t = setTimeout(onTimeout, ms, reason, p._handler);

					this._handler.visit(h, function onFulfill(x) {
						env.clearTimer(t);
						this.resolve(x); // this = h
					}, function onReject(x) {
						env.clearTimer(t);
						this.reject(x); // this = h
					}, h.notify);

					return p;
				};

				function onTimeout(reason, h, ms) {
					var e = typeof reason === 'undefined' ? new TimeoutError('timed out after ' + ms + 'ms') : reason;
					h.reject(e);
				}

				return Promise;
			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;var require;/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {
			/*jshint maxcomplexity:6*/

			// Sniff "best" async scheduling option
			// Prefer process.nextTick or MutationObserver, then check for
			// setTimeout, and finally vertx, since its the only env that doesn't
			// have setTimeout

			var MutationObs;
			var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

			// Default env
			var setTimer = function setTimer(f, ms) {
				return setTimeout(f, ms);
			};
			var clearTimer = function clearTimer(t) {
				return clearTimeout(t);
			};
			var asap = function asap(f) {
				return capturedSetTimeout(f, 0);
			};

			// Detect specific env
			if (isNode()) {
				// Node
				asap = function asap(f) {
					return process.nextTick(f);
				};
			} else if (MutationObs = hasMutationObserver()) {
				// Modern browser
				asap = initMutationObserver(MutationObs);
			} else if (!capturedSetTimeout) {
				// vert.x
				var vertxRequire = require;
				var vertx = __webpack_require__(16);
				setTimer = function setTimer(f, ms) {
					return vertx.setTimer(ms, f);
				};
				clearTimer = vertx.cancelTimer;
				asap = vertx.runOnLoop || vertx.runOnContext;
			}

			return {
				setTimer: setTimer,
				clearTimer: clearTimer,
				asap: asap
			};

			function isNode() {
				return typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]';
			}

			function hasMutationObserver() {
				return typeof MutationObserver === 'function' && MutationObserver || typeof WebKitMutationObserver === 'function' && WebKitMutationObserver;
			}

			function initMutationObserver(MutationObserver) {
				var scheduled;
				var node = document.createTextNode('');
				var o = new MutationObserver(run);
				o.observe(node, { characterData: true });

				function run() {
					var f = scheduled;
					scheduled = void 0;
					f();
				}

				var i = 0;
				return function (f) {
					scheduled = f;
					node.data = i ^= 1;
				};
			}
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			/**
	   * Custom error type for promises rejected by promise.timeout
	   * @param {string} message
	   * @constructor
	   */
			function TimeoutError(message) {
				Error.call(this);
				this.message = message;
				this.name = TimeoutError.name;
				if (typeof Error.captureStackTrace === 'function') {
					Error.captureStackTrace(this, TimeoutError);
				}
			}

			TimeoutError.prototype = Object.create(Error.prototype);
			TimeoutError.prototype.constructor = TimeoutError;

			return TimeoutError;
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var state = __webpack_require__(20);
			var applier = __webpack_require__(21);

			return function array(Promise) {

				var applyFold = applier(Promise);
				var toPromise = Promise.resolve;
				var all = Promise.all;

				var ar = Array.prototype.reduce;
				var arr = Array.prototype.reduceRight;
				var slice = Array.prototype.slice;

				// Additional array combinators

				Promise.any = any;
				Promise.some = some;
				Promise.settle = settle;

				Promise.map = map;
				Promise.filter = filter;
				Promise.reduce = reduce;
				Promise.reduceRight = reduceRight;

				/**
	    * When this promise fulfills with an array, do
	    * onFulfilled.apply(void 0, array)
	    * @param {function} onFulfilled function to apply
	    * @returns {Promise} promise for the result of applying onFulfilled
	    */
				Promise.prototype.spread = function (onFulfilled) {
					return this.then(all).then(function (array) {
						return onFulfilled.apply(this, array);
					});
				};

				return Promise;

				/**
	    * One-winner competitive race.
	    * Return a promise that will fulfill when one of the promises
	    * in the input array fulfills, or will reject when all promises
	    * have rejected.
	    * @param {array} promises
	    * @returns {Promise} promise for the first fulfilled value
	    */
				function any(promises) {
					var p = Promise._defer();
					var resolver = p._handler;
					var l = promises.length >>> 0;

					var pending = l;
					var errors = [];

					for (var h, x, i = 0; i < l; ++i) {
						x = promises[i];
						if (x === void 0 && !(i in promises)) {
							--pending;
							continue;
						}

						h = Promise._handler(x);
						if (h.state() > 0) {
							resolver.become(h);
							Promise._visitRemaining(promises, i, h);
							break;
						} else {
							h.visit(resolver, handleFulfill, handleReject);
						}
					}

					if (pending === 0) {
						resolver.reject(new RangeError('any(): array must not be empty'));
					}

					return p;

					function handleFulfill(x) {
						/*jshint validthis:true*/
						errors = null;
						this.resolve(x); // this === resolver
					}

					function handleReject(e) {
						/*jshint validthis:true*/
						if (this.resolved) {
							// this === resolver
							return;
						}

						errors.push(e);
						if (--pending === 0) {
							this.reject(errors);
						}
					}
				}

				/**
	    * N-winner competitive race
	    * Return a promise that will fulfill when n input promises have
	    * fulfilled, or will reject when it becomes impossible for n
	    * input promises to fulfill (ie when promises.length - n + 1
	    * have rejected)
	    * @param {array} promises
	    * @param {number} n
	    * @returns {Promise} promise for the earliest n fulfillment values
	    *
	    * @deprecated
	    */
				function some(promises, n) {
					/*jshint maxcomplexity:7*/
					var p = Promise._defer();
					var resolver = p._handler;

					var results = [];
					var errors = [];

					var l = promises.length >>> 0;
					var nFulfill = 0;
					var nReject;
					var x, i; // reused in both for() loops

					// First pass: count actual array items
					for (i = 0; i < l; ++i) {
						x = promises[i];
						if (x === void 0 && !(i in promises)) {
							continue;
						}
						++nFulfill;
					}

					// Compute actual goals
					n = Math.max(n, 0);
					nReject = nFulfill - n + 1;
					nFulfill = Math.min(n, nFulfill);

					if (n > nFulfill) {
						resolver.reject(new RangeError('some(): array must contain at least ' + n + ' item(s), but had ' + nFulfill));
					} else if (nFulfill === 0) {
						resolver.resolve(results);
					}

					// Second pass: observe each array item, make progress toward goals
					for (i = 0; i < l; ++i) {
						x = promises[i];
						if (x === void 0 && !(i in promises)) {
							continue;
						}

						Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
					}

					return p;

					function fulfill(x) {
						/*jshint validthis:true*/
						if (this.resolved) {
							// this === resolver
							return;
						}

						results.push(x);
						if (--nFulfill === 0) {
							errors = null;
							this.resolve(results);
						}
					}

					function reject(e) {
						/*jshint validthis:true*/
						if (this.resolved) {
							// this === resolver
							return;
						}

						errors.push(e);
						if (--nReject === 0) {
							results = null;
							this.reject(errors);
						}
					}
				}

				/**
	    * Apply f to the value of each promise in a list of promises
	    * and return a new list containing the results.
	    * @param {array} promises
	    * @param {function(x:*, index:Number):*} f mapping function
	    * @returns {Promise}
	    */
				function map(promises, f) {
					return Promise._traverse(f, promises);
				}

				/**
	    * Filter the provided array of promises using the provided predicate.  Input may
	    * contain promises and values
	    * @param {Array} promises array of promises and values
	    * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	    *  Must return truthy (or promise for truthy) for items to retain.
	    * @returns {Promise} promise that will fulfill with an array containing all items
	    *  for which predicate returned truthy.
	    */
				function filter(promises, predicate) {
					var a = slice.call(promises);
					return Promise._traverse(predicate, a).then(function (keep) {
						return filterSync(a, keep);
					});
				}

				function filterSync(promises, keep) {
					// Safe because we know all promises have fulfilled if we've made it this far
					var l = keep.length;
					var filtered = new Array(l);
					for (var i = 0, j = 0; i < l; ++i) {
						if (keep[i]) {
							filtered[j++] = Promise._handler(promises[i]).value;
						}
					}
					filtered.length = j;
					return filtered;
				}

				/**
	    * Return a promise that will always fulfill with an array containing
	    * the outcome states of all input promises.  The returned promise
	    * will never reject.
	    * @param {Array} promises
	    * @returns {Promise} promise for array of settled state descriptors
	    */
				function settle(promises) {
					return all(promises.map(settleOne));
				}

				function settleOne(p) {
					var h = Promise._handler(p);
					if (h.state() === 0) {
						return toPromise(p).then(state.fulfilled, state.rejected);
					}

					h._unreport();
					return state.inspect(h);
				}

				/**
	    * Traditional reduce function, similar to `Array.prototype.reduce()`, but
	    * input may contain promises and/or values, and reduceFunc
	    * may return either a value or a promise, *and* initialValue may
	    * be a promise for the starting value.
	    * @param {Array|Promise} promises array or promise for an array of anything,
	    *      may contain a mix of promises and values.
	    * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
	    * @returns {Promise} that will resolve to the final reduced value
	    */
				function reduce(promises, f /*, initialValue */) {
					return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2]) : ar.call(promises, liftCombine(f));
				}

				/**
	    * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
	    * input may contain promises and/or values, and reduceFunc
	    * may return either a value or a promise, *and* initialValue may
	    * be a promise for the starting value.
	    * @param {Array|Promise} promises array or promise for an array of anything,
	    *      may contain a mix of promises and values.
	    * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
	    * @returns {Promise} that will resolve to the final reduced value
	    */
				function reduceRight(promises, f /*, initialValue */) {
					return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2]) : arr.call(promises, liftCombine(f));
				}

				function liftCombine(f) {
					return function (z, x, i) {
						return applyFold(f, void 0, [z, x, i]);
					};
				}
			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			return {
				pending: toPendingState,
				fulfilled: toFulfilledState,
				rejected: toRejectedState,
				inspect: inspect
			};

			function toPendingState() {
				return { state: 'pending' };
			}

			function toRejectedState(e) {
				return { state: 'rejected', reason: e };
			}

			function toFulfilledState(x) {
				return { state: 'fulfilled', value: x };
			}

			function inspect(handler) {
				var state = handler.state();
				return state === 0 ? toPendingState() : state > 0 ? toFulfilledState(handler.value) : toRejectedState(handler.value);
			}
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			makeApply.tryCatchResolve = tryCatchResolve;

			return makeApply;

			function makeApply(Promise, call) {
				if (arguments.length < 2) {
					call = tryCatchResolve;
				}

				return apply;

				function apply(f, thisArg, args) {
					var p = Promise._defer();
					var l = args.length;
					var params = new Array(l);
					callAndResolve({ f: f, thisArg: thisArg, args: args, params: params, i: l - 1, call: call }, p._handler);

					return p;
				}

				function callAndResolve(c, h) {
					if (c.i < 0) {
						return call(c.f, c.thisArg, c.params, h);
					}

					var handler = Promise._handler(c.args[c.i]);
					handler.fold(callAndResolveNext, c, void 0, h);
				}

				function callAndResolveNext(c, x, h) {
					c.params[c.i] = x;
					c.i -= 1;
					callAndResolve(c, h);
				}
			}

			function tryCatchResolve(f, thisArg, args, resolver) {
				try {
					resolver.resolve(f.apply(thisArg, args));
				} catch (e) {
					resolver.reject(e);
				}
			}
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			return function flow(Promise) {

				var resolve = Promise.resolve;
				var reject = Promise.reject;
				var origCatch = Promise.prototype['catch'];

				/**
	    * Handle the ultimate fulfillment value or rejection reason, and assume
	    * responsibility for all errors.  If an error propagates out of result
	    * or handleFatalError, it will be rethrown to the host, resulting in a
	    * loud stack track on most platforms and a crash on some.
	    * @param {function?} onResult
	    * @param {function?} onError
	    * @returns {undefined}
	    */
				Promise.prototype.done = function (onResult, onError) {
					this._handler.visit(this._handler.receiver, onResult, onError);
				};

				/**
	    * Add Error-type and predicate matching to catch.  Examples:
	    * promise.catch(TypeError, handleTypeError)
	    *   .catch(predicate, handleMatchedErrors)
	    *   .catch(handleRemainingErrors)
	    * @param onRejected
	    * @returns {*}
	    */
				Promise.prototype['catch'] = Promise.prototype.otherwise = function (onRejected) {
					if (arguments.length < 2) {
						return origCatch.call(this, onRejected);
					}

					if (typeof onRejected !== 'function') {
						return this.ensure(rejectInvalidPredicate);
					}

					return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
				};

				/**
	    * Wraps the provided catch handler, so that it will only be called
	    * if the predicate evaluates truthy
	    * @param {?function} handler
	    * @param {function} predicate
	    * @returns {function} conditional catch handler
	    */
				function createCatchFilter(handler, predicate) {
					return function (e) {
						return evaluatePredicate(e, predicate) ? handler.call(this, e) : reject(e);
					};
				}

				/**
	    * Ensures that onFulfilledOrRejected will be called regardless of whether
	    * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
	    * receive the promises' value or reason.  Any returned value will be disregarded.
	    * onFulfilledOrRejected may throw or return a rejected promise to signal
	    * an additional error.
	    * @param {function} handler handler to be called regardless of
	    *  fulfillment or rejection
	    * @returns {Promise}
	    */
				Promise.prototype['finally'] = Promise.prototype.ensure = function (handler) {
					if (typeof handler !== 'function') {
						return this;
					}

					return this.then(function (x) {
						return runSideEffect(handler, this, identity, x);
					}, function (e) {
						return runSideEffect(handler, this, reject, e);
					});
				};

				function runSideEffect(handler, thisArg, propagate, value) {
					var result = handler.call(thisArg);
					return maybeThenable(result) ? propagateValue(result, propagate, value) : propagate(value);
				}

				function propagateValue(result, propagate, x) {
					return resolve(result).then(function () {
						return propagate(x);
					});
				}

				/**
	    * Recover from a failure by returning a defaultValue.  If defaultValue
	    * is a promise, it's fulfillment value will be used.  If defaultValue is
	    * a promise that rejects, the returned promise will reject with the
	    * same reason.
	    * @param {*} defaultValue
	    * @returns {Promise} new promise
	    */
				Promise.prototype['else'] = Promise.prototype.orElse = function (defaultValue) {
					return this.then(void 0, function () {
						return defaultValue;
					});
				};

				/**
	    * Shortcut for .then(function() { return value; })
	    * @param  {*} value
	    * @return {Promise} a promise that:
	    *  - is fulfilled if value is not a promise, or
	    *  - if value is a promise, will fulfill with its value, or reject
	    *    with its reason.
	    */
				Promise.prototype['yield'] = function (value) {
					return this.then(function () {
						return value;
					});
				};

				/**
	    * Runs a side effect when this promise fulfills, without changing the
	    * fulfillment value.
	    * @param {function} onFulfilledSideEffect
	    * @returns {Promise}
	    */
				Promise.prototype.tap = function (onFulfilledSideEffect) {
					return this.then(onFulfilledSideEffect)['yield'](this);
				};

				return Promise;
			};

			function rejectInvalidPredicate() {
				throw new TypeError('catch predicate must be a function');
			}

			function evaluatePredicate(e, predicate) {
				return isError(predicate) ? e instanceof predicate : predicate(e);
			}

			function isError(predicate) {
				return predicate === Error || predicate != null && predicate.prototype instanceof Error;
			}

			function maybeThenable(x) {
				return ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' || typeof x === 'function') && x !== null;
			}

			function identity(x) {
				return x;
			}
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */
	/** @author Jeff Escalante */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			return function fold(Promise) {

				Promise.prototype.fold = function (f, z) {
					var promise = this._beget();

					this._handler.fold(function (z, x, to) {
						Promise._handler(z).fold(function (x, z, to) {
							to.resolve(f.call(this, z, x));
						}, x, this, to);
					}, z, promise._handler.receiver, promise._handler);

					return promise;
				};

				return Promise;
			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var inspect = __webpack_require__(20).inspect;

			return function inspection(Promise) {

				Promise.prototype.inspect = function () {
					return inspect(Promise._handler(this));
				};

				return Promise;
			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			return function generate(Promise) {

				var resolve = Promise.resolve;

				Promise.iterate = iterate;
				Promise.unfold = unfold;

				return Promise;

				/**
	    * @deprecated Use github.com/cujojs/most streams and most.iterate
	    * Generate a (potentially infinite) stream of promised values:
	    * x, f(x), f(f(x)), etc. until condition(x) returns true
	    * @param {function} f function to generate a new x from the previous x
	    * @param {function} condition function that, given the current x, returns
	    *  truthy when the iterate should stop
	    * @param {function} handler function to handle the value produced by f
	    * @param {*|Promise} x starting value, may be a promise
	    * @return {Promise} the result of the last call to f before
	    *  condition returns true
	    */
				function iterate(f, condition, handler, x) {
					return unfold(function (x) {
						return [x, f(x)];
					}, condition, handler, x);
				}

				/**
	    * @deprecated Use github.com/cujojs/most streams and most.unfold
	    * Generate a (potentially infinite) stream of promised values
	    * by applying handler(generator(seed)) iteratively until
	    * condition(seed) returns true.
	    * @param {function} unspool function that generates a [value, newSeed]
	    *  given a seed.
	    * @param {function} condition function that, given the current seed, returns
	    *  truthy when the unfold should stop
	    * @param {function} handler function to handle the value produced by unspool
	    * @param x {*|Promise} starting value, may be a promise
	    * @return {Promise} the result of the last value produced by unspool before
	    *  condition returns true
	    */
				function unfold(unspool, condition, handler, x) {
					return resolve(x).then(function (seed) {
						return resolve(condition(seed)).then(function (done) {
							return done ? seed : resolve(unspool(seed)).spread(next);
						});
					});

					function next(item, newSeed) {
						return resolve(handler(item)).then(function () {
							return unfold(unspool, condition, handler, newSeed);
						});
					}
				}
			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			return function progress(Promise) {

				/**
	    * @deprecated
	    * Register a progress handler for this promise
	    * @param {function} onProgress
	    * @returns {Promise}
	    */
				Promise.prototype.progress = function (onProgress) {
					return this.then(void 0, void 0, onProgress);
				};

				return Promise;
			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			return function addWith(Promise) {
				/**
	    * Returns a promise whose handlers will be called with `this` set to
	    * the supplied receiver.  Subsequent promises derived from the
	    * returned promise will also have their handlers called with receiver
	    * as `this`. Calling `with` with undefined or no arguments will return
	    * a promise whose handlers will again be called in the usual Promises/A+
	    * way (no `this`) thus safely undoing any previous `with` in the
	    * promise chain.
	    *
	    * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
	    * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
	    *
	    * @param {object} receiver `this` value for all handlers attached to
	    *  the returned promise.
	    * @returns {Promise}
	    */
				Promise.prototype['with'] = Promise.prototype.withThis = function (receiver) {
					var p = this._beget();
					var child = p._handler;
					child.receiver = receiver;
					this._handler.chain(child, receiver);
					return p;
				};

				return Promise;
			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var setTimer = __webpack_require__(15).setTimer;
			var format = __webpack_require__(29);

			return function unhandledRejection(Promise) {

				var logError = noop;
				var logInfo = noop;
				var localConsole;

				if (typeof console !== 'undefined') {
					// Alias console to prevent things like uglify's drop_console option from
					// removing console.log/error. Unhandled rejections fall into the same
					// category as uncaught exceptions, and build tools shouldn't silence them.
					localConsole = console;
					logError = typeof localConsole.error !== 'undefined' ? function (e) {
						localConsole.error(e);
					} : function (e) {
						localConsole.log(e);
					};

					logInfo = typeof localConsole.info !== 'undefined' ? function (e) {
						localConsole.info(e);
					} : function (e) {
						localConsole.log(e);
					};
				}

				Promise.onPotentiallyUnhandledRejection = function (rejection) {
					enqueue(report, rejection);
				};

				Promise.onPotentiallyUnhandledRejectionHandled = function (rejection) {
					enqueue(unreport, rejection);
				};

				Promise.onFatalRejection = function (rejection) {
					enqueue(throwit, rejection.value);
				};

				var tasks = [];
				var reported = [];
				var running = null;

				function report(r) {
					if (!r.handled) {
						reported.push(r);
						logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
					}
				}

				function unreport(r) {
					var i = reported.indexOf(r);
					if (i >= 0) {
						reported.splice(i, 1);
						logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
					}
				}

				function enqueue(f, x) {
					tasks.push(f, x);
					if (running === null) {
						running = setTimer(flush, 0);
					}
				}

				function flush() {
					running = null;
					while (tasks.length > 0) {
						tasks.shift()(tasks.shift());
					}
				}

				return Promise;
			};

			function throwit(e) {
				throw e;
			}

			function noop() {}
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			return {
				formatError: formatError,
				formatObject: formatObject,
				tryStringify: tryStringify
			};

			/**
	   * Format an error into a string.  If e is an Error and has a stack property,
	   * it's returned.  Otherwise, e is formatted using formatObject, with a
	   * warning added about e not being a proper Error.
	   * @param {*} e
	   * @returns {String} formatted string, suitable for output to developers
	   */
			function formatError(e) {
				var s = (typeof e === 'undefined' ? 'undefined' : _typeof(e)) === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
				return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
			}

			/**
	   * Format an object, detecting "plain" objects and running them through
	   * JSON.stringify if possible.
	   * @param {Object} o
	   * @returns {string}
	   */
			function formatObject(o) {
				var s = String(o);
				if (s === '[object Object]' && typeof JSON !== 'undefined') {
					s = tryStringify(o, s);
				}
				return s;
			}

			/**
	   * Try to return the result of JSON.stringify(x).  If that fails, return
	   * defaultValue
	   * @param {*} x
	   * @param {*} defaultValue
	   * @returns {String|*} JSON.stringify(x) or defaultValue
	   */
			function tryStringify(x, defaultValue) {
				try {
					return JSON.stringify(x);
				} catch (e) {
					return defaultValue;
				}
			}
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require) {

			var makePromise = __webpack_require__(31);
			var Scheduler = __webpack_require__(32);
			var async = __webpack_require__(15).asap;

			return makePromise({
				scheduler: new Scheduler(async)
			});
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			return function makePromise(environment) {

				var tasks = environment.scheduler;
				var emitRejection = initEmitRejection();

				var objectCreate = Object.create || function (proto) {
					function Child() {}
					Child.prototype = proto;
					return new Child();
				};

				/**
	    * Create a promise whose fate is determined by resolver
	    * @constructor
	    * @returns {Promise} promise
	    * @name Promise
	    */
				function Promise(resolver, handler) {
					this._handler = resolver === Handler ? handler : init(resolver);
				}

				/**
	    * Run the supplied resolver
	    * @param resolver
	    * @returns {Pending}
	    */
				function init(resolver) {
					var handler = new Pending();

					try {
						resolver(promiseResolve, promiseReject, promiseNotify);
					} catch (e) {
						promiseReject(e);
					}

					return handler;

					/**
	     * Transition from pre-resolution state to post-resolution state, notifying
	     * all listeners of the ultimate fulfillment or rejection
	     * @param {*} x resolution value
	     */
					function promiseResolve(x) {
						handler.resolve(x);
					}
					/**
	     * Reject this promise with reason, which will be used verbatim
	     * @param {Error|*} reason rejection reason, strongly suggested
	     *   to be an Error type
	     */
					function promiseReject(reason) {
						handler.reject(reason);
					}

					/**
	     * @deprecated
	     * Issue a progress event, notifying all progress listeners
	     * @param {*} x progress event payload to pass to all listeners
	     */
					function promiseNotify(x) {
						handler.notify(x);
					}
				}

				// Creation

				Promise.resolve = resolve;
				Promise.reject = reject;
				Promise.never = never;

				Promise._defer = defer;
				Promise._handler = getHandler;

				/**
	    * Returns a trusted promise. If x is already a trusted promise, it is
	    * returned, otherwise returns a new trusted Promise which follows x.
	    * @param  {*} x
	    * @return {Promise} promise
	    */
				function resolve(x) {
					return isPromise(x) ? x : new Promise(Handler, new Async(getHandler(x)));
				}

				/**
	    * Return a reject promise with x as its reason (x is used verbatim)
	    * @param {*} x
	    * @returns {Promise} rejected promise
	    */
				function reject(x) {
					return new Promise(Handler, new Async(new Rejected(x)));
				}

				/**
	    * Return a promise that remains pending forever
	    * @returns {Promise} forever-pending promise.
	    */
				function never() {
					return foreverPendingPromise; // Should be frozen
				}

				/**
	    * Creates an internal {promise, resolver} pair
	    * @private
	    * @returns {Promise}
	    */
				function defer() {
					return new Promise(Handler, new Pending());
				}

				// Transformation and flow control

				/**
	    * Transform this promise's fulfillment value, returning a new Promise
	    * for the transformed result.  If the promise cannot be fulfilled, onRejected
	    * is called with the reason.  onProgress *may* be called with updates toward
	    * this promise's fulfillment.
	    * @param {function=} onFulfilled fulfillment handler
	    * @param {function=} onRejected rejection handler
	    * @param {function=} onProgress @deprecated progress handler
	    * @return {Promise} new promise
	    */
				Promise.prototype.then = function (onFulfilled, onRejected, onProgress) {
					var parent = this._handler;
					var state = parent.join().state();

					if (typeof onFulfilled !== 'function' && state > 0 || typeof onRejected !== 'function' && state < 0) {
						// Short circuit: value will not change, simply share handler
						return new this.constructor(Handler, parent);
					}

					var p = this._beget();
					var child = p._handler;

					parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

					return p;
				};

				/**
	    * If this promise cannot be fulfilled due to an error, call onRejected to
	    * handle the error. Shortcut for .then(undefined, onRejected)
	    * @param {function?} onRejected
	    * @return {Promise}
	    */
				Promise.prototype['catch'] = function (onRejected) {
					return this.then(void 0, onRejected);
				};

				/**
	    * Creates a new, pending promise of the same type as this promise
	    * @private
	    * @returns {Promise}
	    */
				Promise.prototype._beget = function () {
					return begetFrom(this._handler, this.constructor);
				};

				function begetFrom(parent, Promise) {
					var child = new Pending(parent.receiver, parent.join().context);
					return new Promise(Handler, child);
				}

				// Array combinators

				Promise.all = all;
				Promise.race = race;
				Promise._traverse = traverse;

				/**
	    * Return a promise that will fulfill when all promises in the
	    * input array have fulfilled, or will reject when one of the
	    * promises rejects.
	    * @param {array} promises array of promises
	    * @returns {Promise} promise for array of fulfillment values
	    */
				function all(promises) {
					return traverseWith(snd, null, promises);
				}

				/**
	    * Array<Promise<X>> -> Promise<Array<f(X)>>
	    * @private
	    * @param {function} f function to apply to each promise's value
	    * @param {Array} promises array of promises
	    * @returns {Promise} promise for transformed values
	    */
				function traverse(f, promises) {
					return traverseWith(tryCatch2, f, promises);
				}

				function traverseWith(tryMap, f, promises) {
					var handler = typeof f === 'function' ? mapAt : settleAt;

					var resolver = new Pending();
					var pending = promises.length >>> 0;
					var results = new Array(pending);

					for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
						x = promises[i];

						if (x === void 0 && !(i in promises)) {
							--pending;
							continue;
						}

						traverseAt(promises, handler, i, x, resolver);
					}

					if (pending === 0) {
						resolver.become(new Fulfilled(results));
					}

					return new Promise(Handler, resolver);

					function mapAt(i, x, resolver) {
						if (!resolver.resolved) {
							traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
						}
					}

					function settleAt(i, x, resolver) {
						results[i] = x;
						if (--pending === 0) {
							resolver.become(new Fulfilled(results));
						}
					}
				}

				function traverseAt(promises, handler, i, x, resolver) {
					if (maybeThenable(x)) {
						var h = getHandlerMaybeThenable(x);
						var s = h.state();

						if (s === 0) {
							h.fold(handler, i, void 0, resolver);
						} else if (s > 0) {
							handler(i, h.value, resolver);
						} else {
							resolver.become(h);
							visitRemaining(promises, i + 1, h);
						}
					} else {
						handler(i, x, resolver);
					}
				}

				Promise._visitRemaining = visitRemaining;
				function visitRemaining(promises, start, handler) {
					for (var i = start; i < promises.length; ++i) {
						markAsHandled(getHandler(promises[i]), handler);
					}
				}

				function markAsHandled(h, handler) {
					if (h === handler) {
						return;
					}

					var s = h.state();
					if (s === 0) {
						h.visit(h, void 0, h._unreport);
					} else if (s < 0) {
						h._unreport();
					}
				}

				/**
	    * Fulfill-reject competitive race. Return a promise that will settle
	    * to the same state as the earliest input promise to settle.
	    *
	    * WARNING: The ES6 Promise spec requires that race()ing an empty array
	    * must return a promise that is pending forever.  This implementation
	    * returns a singleton forever-pending promise, the same singleton that is
	    * returned by Promise.never(), thus can be checked with ===
	    *
	    * @param {array} promises array of promises to race
	    * @returns {Promise} if input is non-empty, a promise that will settle
	    * to the same outcome as the earliest input promise to settle. if empty
	    * is empty, returns a promise that will never settle.
	    */
				function race(promises) {
					if ((typeof promises === 'undefined' ? 'undefined' : _typeof(promises)) !== 'object' || promises === null) {
						return reject(new TypeError('non-iterable passed to race()'));
					}

					// Sigh, race([]) is untestable unless we return *something*
					// that is recognizable without calling .then() on it.
					return promises.length === 0 ? never() : promises.length === 1 ? resolve(promises[0]) : runRace(promises);
				}

				function runRace(promises) {
					var resolver = new Pending();
					var i, x, h;
					for (i = 0; i < promises.length; ++i) {
						x = promises[i];
						if (x === void 0 && !(i in promises)) {
							continue;
						}

						h = getHandler(x);
						if (h.state() !== 0) {
							resolver.become(h);
							visitRemaining(promises, i + 1, h);
							break;
						} else {
							h.visit(resolver, resolver.resolve, resolver.reject);
						}
					}
					return new Promise(Handler, resolver);
				}

				// Promise internals
				// Below this, everything is @private

				/**
	    * Get an appropriate handler for x, without checking for cycles
	    * @param {*} x
	    * @returns {object} handler
	    */
				function getHandler(x) {
					if (isPromise(x)) {
						return x._handler.join();
					}
					return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
				}

				/**
	    * Get a handler for thenable x.
	    * NOTE: You must only call this if maybeThenable(x) == true
	    * @param {object|function|Promise} x
	    * @returns {object} handler
	    */
				function getHandlerMaybeThenable(x) {
					return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
				}

				/**
	    * Get a handler for potentially untrusted thenable x
	    * @param {*} x
	    * @returns {object} handler
	    */
				function getHandlerUntrusted(x) {
					try {
						var untrustedThen = x.then;
						return typeof untrustedThen === 'function' ? new Thenable(untrustedThen, x) : new Fulfilled(x);
					} catch (e) {
						return new Rejected(e);
					}
				}

				/**
	    * Handler for a promise that is pending forever
	    * @constructor
	    */
				function Handler() {}

				Handler.prototype.when = Handler.prototype.become = Handler.prototype.notify // deprecated
				 = Handler.prototype.fail = Handler.prototype._unreport = Handler.prototype._report = noop;

				Handler.prototype._state = 0;

				Handler.prototype.state = function () {
					return this._state;
				};

				/**
	    * Recursively collapse handler chain to find the handler
	    * nearest to the fully resolved value.
	    * @returns {object} handler nearest the fully resolved value
	    */
				Handler.prototype.join = function () {
					var h = this;
					while (h.handler !== void 0) {
						h = h.handler;
					}
					return h;
				};

				Handler.prototype.chain = function (to, receiver, fulfilled, rejected, progress) {
					this.when({
						resolver: to,
						receiver: receiver,
						fulfilled: fulfilled,
						rejected: rejected,
						progress: progress
					});
				};

				Handler.prototype.visit = function (receiver, fulfilled, rejected, progress) {
					this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
				};

				Handler.prototype.fold = function (f, z, c, to) {
					this.when(new Fold(f, z, c, to));
				};

				/**
	    * Handler that invokes fail() on any handler it becomes
	    * @constructor
	    */
				function FailIfRejected() {}

				inherit(Handler, FailIfRejected);

				FailIfRejected.prototype.become = function (h) {
					h.fail();
				};

				var failIfRejected = new FailIfRejected();

				/**
	    * Handler that manages a queue of consumers waiting on a pending promise
	    * @constructor
	    */
				function Pending(receiver, inheritedContext) {
					Promise.createContext(this, inheritedContext);

					this.consumers = void 0;
					this.receiver = receiver;
					this.handler = void 0;
					this.resolved = false;
				}

				inherit(Handler, Pending);

				Pending.prototype._state = 0;

				Pending.prototype.resolve = function (x) {
					this.become(getHandler(x));
				};

				Pending.prototype.reject = function (x) {
					if (this.resolved) {
						return;
					}

					this.become(new Rejected(x));
				};

				Pending.prototype.join = function () {
					if (!this.resolved) {
						return this;
					}

					var h = this;

					while (h.handler !== void 0) {
						h = h.handler;
						if (h === this) {
							return this.handler = cycle();
						}
					}

					return h;
				};

				Pending.prototype.run = function () {
					var q = this.consumers;
					var handler = this.handler;
					this.handler = this.handler.join();
					this.consumers = void 0;

					for (var i = 0; i < q.length; ++i) {
						handler.when(q[i]);
					}
				};

				Pending.prototype.become = function (handler) {
					if (this.resolved) {
						return;
					}

					this.resolved = true;
					this.handler = handler;
					if (this.consumers !== void 0) {
						tasks.enqueue(this);
					}

					if (this.context !== void 0) {
						handler._report(this.context);
					}
				};

				Pending.prototype.when = function (continuation) {
					if (this.resolved) {
						tasks.enqueue(new ContinuationTask(continuation, this.handler));
					} else {
						if (this.consumers === void 0) {
							this.consumers = [continuation];
						} else {
							this.consumers.push(continuation);
						}
					}
				};

				/**
	    * @deprecated
	    */
				Pending.prototype.notify = function (x) {
					if (!this.resolved) {
						tasks.enqueue(new ProgressTask(x, this));
					}
				};

				Pending.prototype.fail = function (context) {
					var c = typeof context === 'undefined' ? this.context : context;
					this.resolved && this.handler.join().fail(c);
				};

				Pending.prototype._report = function (context) {
					this.resolved && this.handler.join()._report(context);
				};

				Pending.prototype._unreport = function () {
					this.resolved && this.handler.join()._unreport();
				};

				/**
	    * Wrap another handler and force it into a future stack
	    * @param {object} handler
	    * @constructor
	    */
				function Async(handler) {
					this.handler = handler;
				}

				inherit(Handler, Async);

				Async.prototype.when = function (continuation) {
					tasks.enqueue(new ContinuationTask(continuation, this));
				};

				Async.prototype._report = function (context) {
					this.join()._report(context);
				};

				Async.prototype._unreport = function () {
					this.join()._unreport();
				};

				/**
	    * Handler that wraps an untrusted thenable and assimilates it in a future stack
	    * @param {function} then
	    * @param {{then: function}} thenable
	    * @constructor
	    */
				function Thenable(then, thenable) {
					Pending.call(this);
					tasks.enqueue(new AssimilateTask(then, thenable, this));
				}

				inherit(Pending, Thenable);

				/**
	    * Handler for a fulfilled promise
	    * @param {*} x fulfillment value
	    * @constructor
	    */
				function Fulfilled(x) {
					Promise.createContext(this);
					this.value = x;
				}

				inherit(Handler, Fulfilled);

				Fulfilled.prototype._state = 1;

				Fulfilled.prototype.fold = function (f, z, c, to) {
					runContinuation3(f, z, this, c, to);
				};

				Fulfilled.prototype.when = function (cont) {
					runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
				};

				var errorId = 0;

				/**
	    * Handler for a rejected promise
	    * @param {*} x rejection reason
	    * @constructor
	    */
				function Rejected(x) {
					Promise.createContext(this);

					this.id = ++errorId;
					this.value = x;
					this.handled = false;
					this.reported = false;

					this._report();
				}

				inherit(Handler, Rejected);

				Rejected.prototype._state = -1;

				Rejected.prototype.fold = function (f, z, c, to) {
					to.become(this);
				};

				Rejected.prototype.when = function (cont) {
					if (typeof cont.rejected === 'function') {
						this._unreport();
					}
					runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
				};

				Rejected.prototype._report = function (context) {
					tasks.afterQueue(new ReportTask(this, context));
				};

				Rejected.prototype._unreport = function () {
					if (this.handled) {
						return;
					}
					this.handled = true;
					tasks.afterQueue(new UnreportTask(this));
				};

				Rejected.prototype.fail = function (context) {
					this.reported = true;
					emitRejection('unhandledRejection', this);
					Promise.onFatalRejection(this, context === void 0 ? this.context : context);
				};

				function ReportTask(rejection, context) {
					this.rejection = rejection;
					this.context = context;
				}

				ReportTask.prototype.run = function () {
					if (!this.rejection.handled && !this.rejection.reported) {
						this.rejection.reported = true;
						emitRejection('unhandledRejection', this.rejection) || Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
					}
				};

				function UnreportTask(rejection) {
					this.rejection = rejection;
				}

				UnreportTask.prototype.run = function () {
					if (this.rejection.reported) {
						emitRejection('rejectionHandled', this.rejection) || Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
					}
				};

				// Unhandled rejection hooks
				// By default, everything is a noop

				Promise.createContext = Promise.enterContext = Promise.exitContext = Promise.onPotentiallyUnhandledRejection = Promise.onPotentiallyUnhandledRejectionHandled = Promise.onFatalRejection = noop;

				// Errors and singletons

				var foreverPendingHandler = new Handler();
				var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

				function cycle() {
					return new Rejected(new TypeError('Promise cycle'));
				}

				// Task runners

				/**
	    * Run a single consumer
	    * @constructor
	    */
				function ContinuationTask(continuation, handler) {
					this.continuation = continuation;
					this.handler = handler;
				}

				ContinuationTask.prototype.run = function () {
					this.handler.join().when(this.continuation);
				};

				/**
	    * Run a queue of progress handlers
	    * @constructor
	    */
				function ProgressTask(value, handler) {
					this.handler = handler;
					this.value = value;
				}

				ProgressTask.prototype.run = function () {
					var q = this.handler.consumers;
					if (q === void 0) {
						return;
					}

					for (var c, i = 0; i < q.length; ++i) {
						c = q[i];
						runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
					}
				};

				/**
	    * Assimilate a thenable, sending it's value to resolver
	    * @param {function} then
	    * @param {object|function} thenable
	    * @param {object} resolver
	    * @constructor
	    */
				function AssimilateTask(then, thenable, resolver) {
					this._then = then;
					this.thenable = thenable;
					this.resolver = resolver;
				}

				AssimilateTask.prototype.run = function () {
					var h = this.resolver;
					tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

					function _resolve(x) {
						h.resolve(x);
					}
					function _reject(x) {
						h.reject(x);
					}
					function _notify(x) {
						h.notify(x);
					}
				};

				function tryAssimilate(then, thenable, resolve, reject, notify) {
					try {
						then.call(thenable, resolve, reject, notify);
					} catch (e) {
						reject(e);
					}
				}

				/**
	    * Fold a handler value with z
	    * @constructor
	    */
				function Fold(f, z, c, to) {
					this.f = f;this.z = z;this.c = c;this.to = to;
					this.resolver = failIfRejected;
					this.receiver = this;
				}

				Fold.prototype.fulfilled = function (x) {
					this.f.call(this.c, this.z, x, this.to);
				};

				Fold.prototype.rejected = function (x) {
					this.to.reject(x);
				};

				Fold.prototype.progress = function (x) {
					this.to.notify(x);
				};

				// Other helpers

				/**
	    * @param {*} x
	    * @returns {boolean} true iff x is a trusted Promise
	    */
				function isPromise(x) {
					return x instanceof Promise;
				}

				/**
	    * Test just enough to rule out primitives, in order to take faster
	    * paths in some code
	    * @param {*} x
	    * @returns {boolean} false iff x is guaranteed *not* to be a thenable
	    */
				function maybeThenable(x) {
					return ((typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' || typeof x === 'function') && x !== null;
				}

				function runContinuation1(f, h, receiver, next) {
					if (typeof f !== 'function') {
						return next.become(h);
					}

					Promise.enterContext(h);
					tryCatchReject(f, h.value, receiver, next);
					Promise.exitContext();
				}

				function runContinuation3(f, x, h, receiver, next) {
					if (typeof f !== 'function') {
						return next.become(h);
					}

					Promise.enterContext(h);
					tryCatchReject3(f, x, h.value, receiver, next);
					Promise.exitContext();
				}

				/**
	    * @deprecated
	    */
				function runNotify(f, x, h, receiver, next) {
					if (typeof f !== 'function') {
						return next.notify(x);
					}

					Promise.enterContext(h);
					tryCatchReturn(f, x, receiver, next);
					Promise.exitContext();
				}

				function tryCatch2(f, a, b) {
					try {
						return f(a, b);
					} catch (e) {
						return reject(e);
					}
				}

				/**
	    * Return f.call(thisArg, x), or if it throws return a rejected promise for
	    * the thrown exception
	    */
				function tryCatchReject(f, x, thisArg, next) {
					try {
						next.become(getHandler(f.call(thisArg, x)));
					} catch (e) {
						next.become(new Rejected(e));
					}
				}

				/**
	    * Same as above, but includes the extra argument parameter.
	    */
				function tryCatchReject3(f, x, y, thisArg, next) {
					try {
						f.call(thisArg, x, y, next);
					} catch (e) {
						next.become(new Rejected(e));
					}
				}

				/**
	    * @deprecated
	    * Return f.call(thisArg, x), or if it throws, *return* the exception
	    */
				function tryCatchReturn(f, x, thisArg, next) {
					try {
						next.notify(f.call(thisArg, x));
					} catch (e) {
						next.notify(e);
					}
				}

				function inherit(Parent, Child) {
					Child.prototype = objectCreate(Parent.prototype);
					Child.prototype.constructor = Child;
				}

				function snd(x, y) {
					return y;
				}

				function noop() {}

				function initEmitRejection() {
					/*global process, self, CustomEvent*/
					if (typeof process !== 'undefined' && process !== null && typeof process.emit === 'function') {
						// Returning falsy here means to call the default
						// onPotentiallyUnhandledRejection API.  This is safe even in
						// browserify since process.emit always returns falsy in browserify:
						// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
						return function (type, rejection) {
							return type === 'unhandledRejection' ? process.emit(type, rejection.value, rejection) : process.emit(type, rejection);
						};
					} else if (typeof self !== 'undefined' && typeof CustomEvent === 'function') {
						return function (noop, self, CustomEvent) {
							var hasCustomEvent = false;
							try {
								var ev = new CustomEvent('unhandledRejection');
								hasCustomEvent = ev instanceof CustomEvent;
							} catch (e) {}

							return !hasCustomEvent ? noop : function (type, rejection) {
								var ev = new CustomEvent(type, {
									detail: {
										reason: rejection.value,
										key: rejection
									},
									bubbles: false,
									cancelable: true
								});

								return !self.dispatchEvent(ev);
							};
						}(noop, self, CustomEvent);
					}

					return noop;
				}

				return Promise;
			};
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	(function (define) {
		'use strict';

		!(__WEBPACK_AMD_DEFINE_RESULT__ = function () {

			// Credit to Twisol (https://github.com/Twisol) for suggesting
			// this type of extensible queue + trampoline approach for next-tick conflation.

			/**
	   * Async task scheduler
	   * @param {function} async function to schedule a single async function
	   * @constructor
	   */
			function Scheduler(async) {
				this._async = async;
				this._running = false;

				this._queue = this;
				this._queueLen = 0;
				this._afterQueue = {};
				this._afterQueueLen = 0;

				var self = this;
				this.drain = function () {
					self._drain();
				};
			}

			/**
	   * Enqueue a task
	   * @param {{ run:function }} task
	   */
			Scheduler.prototype.enqueue = function (task) {
				this._queue[this._queueLen++] = task;
				this.run();
			};

			/**
	   * Enqueue a task to run after the main task queue
	   * @param {{ run:function }} task
	   */
			Scheduler.prototype.afterQueue = function (task) {
				this._afterQueue[this._afterQueueLen++] = task;
				this.run();
			};

			Scheduler.prototype.run = function () {
				if (!this._running) {
					this._running = true;
					this._async(this.drain);
				}
			};

			/**
	   * Drain the handler queue entirely, and then the after queue
	   */
			Scheduler.prototype._drain = function () {
				var i = 0;
				for (; i < this._queueLen; ++i) {
					this._queue[i].run();
					this._queue[i] = void 0;
				}

				this._queueLen = 0;
				this._running = false;

				for (i = 0; i < this._afterQueueLen; ++i) {
					this._afterQueue[i].run();
					this._afterQueue[i] = void 0;
				}

				this._afterQueueLen = 0;
			};

			return Scheduler;
		}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	})(__webpack_require__(17));

/***/ },
/* 33 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/*
	 Yaku v0.15.9
	 (c) 2015 Yad Smood. http://ysmood.org
	 License MIT
	*/
	(function () {
	    "use strict";

	    var $undefined,
	        $null = null,
	        root = (typeof global === "undefined" ? "undefined" : _typeof(global)) === "object" ? global : window,
	        isLongStackTrace = false,
	        process = root.process,
	        Arr = Array,
	        Err = Error,
	        $rejected = 0,
	        $resolved = 1,
	        $pending = 2,
	        $Symbol = "Symbol",
	        $iterator = "iterator",
	        $species = "species",
	        $speciesKey = $Symbol + "(" + $species + ")",
	        $return = "return",
	        $unhandled = "_uh",
	        $promiseTrace = "_pt",
	        $settlerTrace = "_st",
	        $invalidThis = "Invalid this",
	        $invalidArgument = "Invalid argument",
	        $fromPrevious = "\nFrom previous ",
	        $promiseCircularChain = "Chaining cycle detected for promise",
	        $unhandledRejectionMsg = "Uncaught (in promise)",
	        $rejectionHandled = "rejectionHandled",
	        $unhandledRejection = "unhandledRejection",
	        $tryCatchFn,
	        $tryCatchThis,
	        $tryErr = { e: $null },
	        $noop = function $noop() {};

	    /**
	     * This class follows the [Promises/A+](https://promisesaplus.com) and
	     * [ES6](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects) spec
	     * with some extra helpers.
	     * @param  {Function} executor Function object with two arguments resolve, reject.
	     * The first argument fulfills the promise, the second argument rejects it.
	     * We can call these functions, once our operation is completed.
	     */
	    var Yaku = module.exports = function Promise(executor) {
	        var self = this,
	            err;

	        // "this._s" is the internal state of: pending, resolved or rejected
	        // "this._v" is the internal value

	        if (!isObject(self) || self._s !== $undefined) throw genTypeError($invalidThis);

	        self._s = $pending;

	        if (isLongStackTrace) self[$promiseTrace] = genTraceInfo();

	        if (executor !== $noop) {
	            if (!isFunction(executor)) throw genTypeError($invalidArgument);

	            err = genTryCatcher(executor)(genSettler(self, $resolved), genSettler(self, $rejected));

	            if (err === $tryErr) settlePromise(self, $rejected, err.e);
	        }
	    };

	    Yaku["default"] = Yaku;

	    extendPrototype(Yaku, {
	        /**
	         * Appends fulfillment and rejection handlers to the promise,
	         * and returns a new promise resolving to the return value of the called handler.
	         * @param  {Function} onFulfilled Optional. Called when the Promise is resolved.
	         * @param  {Function} onRejected  Optional. Called when the Promise is rejected.
	         * @return {Yaku} It will return a new Yaku which will resolve or reject after
	         * @example
	         * the current Promise.
	         * ```js
	         * var Promise = require('yaku');
	         * var p = Promise.resolve(10);
	         *
	         * p.then((v) => {
	         *     console.log(v);
	         * });
	         * ```
	         */
	        then: function then(onFulfilled, onRejected) {
	            if (this._s === undefined) throw genTypeError();

	            return addHandler(this, newCapablePromise(Yaku.speciesConstructor(this, Yaku)), onFulfilled, onRejected);
	        },

	        /**
	         * The `catch()` method returns a Promise and deals with rejected cases only.
	         * It behaves the same as calling `Promise.prototype.then(undefined, onRejected)`.
	         * @param  {Function} onRejected A Function called when the Promise is rejected.
	         * This function has one argument, the rejection reason.
	         * @return {Yaku} A Promise that deals with rejected cases only.
	         * @example
	         * ```js
	         * var Promise = require('yaku');
	         * var p = Promise.reject(new Error("ERR"));
	         *
	         * p['catch']((v) => {
	         *     console.log(v);
	         * });
	         * ```
	         */
	        "catch": function _catch(onRejected) {
	            return this.then($undefined, onRejected);
	        },

	        // The number of current promises that attach to this Yaku instance.
	        _pCount: 0,

	        // The parent Yaku.
	        _pre: $null,

	        // A unique type flag, it helps different versions of Yaku know each other.
	        _Yaku: 1
	    });

	    /**
	     * The `Promise.resolve(value)` method returns a Promise object that is resolved with the given value.
	     * If the value is a thenable (i.e. has a then method), the returned promise will "follow" that thenable,
	     * adopting its eventual state; otherwise the returned promise will be fulfilled with the value.
	     * @param  {Any} value Argument to be resolved by this Promise.
	     * Can also be a Promise or a thenable to resolve.
	     * @return {Yaku}
	     * @example
	     * ```js
	     * var Promise = require('yaku');
	     * var p = Promise.resolve(10);
	     * ```
	     */
	    Yaku.resolve = function resolve(val) {
	        return isYaku(val) ? val : settleWithX(newCapablePromise(this), val);
	    };

	    /**
	     * The `Promise.reject(reason)` method returns a Promise object that is rejected with the given reason.
	     * @param  {Any} reason Reason why this Promise rejected.
	     * @return {Yaku}
	     * @example
	     * ```js
	     * var Promise = require('yaku');
	     * var p = Promise.reject(new Error("ERR"));
	     * ```
	     */
	    Yaku.reject = function reject(reason) {
	        return settlePromise(newCapablePromise(this), $rejected, reason);
	    };

	    /**
	     * The `Promise.race(iterable)` method returns a promise that resolves or rejects
	     * as soon as one of the promises in the iterable resolves or rejects,
	     * with the value or reason from that promise.
	     * @param  {iterable} iterable An iterable object, such as an Array.
	     * @return {Yaku} The race function returns a Promise that is settled
	     * the same way as the first passed promise to settle.
	     * It resolves or rejects, whichever happens first.
	     * @example
	     * ```js
	     * var Promise = require('yaku');
	     * Promise.race([
	     *     123,
	     *     Promise.resolve(0)
	     * ])
	     * .then((value) => {
	     *     console.log(value); // => 123
	     * });
	     * ```
	     */
	    Yaku.race = function race(iterable) {
	        var self = this,
	            p = newCapablePromise(self),
	            resolve = function resolve(val) {
	            settlePromise(p, $resolved, val);
	        },
	            reject = function reject(val) {
	            settlePromise(p, $rejected, val);
	        },
	            ret = genTryCatcher(each)(iterable, function (v) {
	            self.resolve(v).then(resolve, reject);
	        });

	        if (ret === $tryErr) return self.reject(ret.e);

	        return p;
	    };

	    /**
	     * The `Promise.all(iterable)` method returns a promise that resolves when
	     * all of the promises in the iterable argument have resolved.
	     *
	     * The result is passed as an array of values from all the promises.
	     * If something passed in the iterable array is not a promise,
	     * it's converted to one by Promise.resolve. If any of the passed in promises rejects,
	     * the all Promise immediately rejects with the value of the promise that rejected,
	     * discarding all the other promises whether or not they have resolved.
	     * @param  {iterable} iterable An iterable object, such as an Array.
	     * @return {Yaku}
	     * @example
	     * ```js
	     * var Promise = require('yaku');
	     * Promise.all([
	     *     123,
	     *     Promise.resolve(0)
	     * ])
	     * .then((values) => {
	     *     console.log(values); // => [123, 0]
	     * });
	     * ```
	     * @example
	     * Use with iterable.
	     * ```js
	     * var Promise = require('yaku');
	     * Promise.all((function * () {
	     *     yield 10;
	     *     yield new Promise(function (r) { setTimeout(r, 1000, "OK") });
	     * })())
	     * .then((values) => {
	     *     console.log(values); // => [123, 0]
	     * });
	     * ```
	     */
	    Yaku.all = function all(iterable) {
	        var self = this,
	            p1 = newCapablePromise(self),
	            res = [],
	            ret;

	        function reject(reason) {
	            settlePromise(p1, $rejected, reason);
	        }

	        ret = genTryCatcher(each)(iterable, function (item, i) {
	            self.resolve(item).then(function (value) {
	                res[i] = value;
	                if (! --ret) settlePromise(p1, $resolved, res);
	            }, reject);
	        });

	        if (ret === $tryErr) return self.reject(ret.e);

	        if (!ret) settlePromise(p1, $resolved, []);

	        return p1;
	    };

	    /**
	     * The ES6 Symbol object that Yaku should use, by default it will use the
	     * global one.
	     * @type {Object}
	     * @example
	     * ```js
	     * var core = require("core-js/library");
	     * var Promise = require("yaku");
	     * Promise.Symbol = core.Symbol;
	     * ```
	     */
	    Yaku.Symbol = root[$Symbol] || {};

	    // To support browsers that don't support `Object.defineProperty`.
	    genTryCatcher(function () {
	        Object.defineProperty(Yaku, getSpecies(), {
	            get: function get() {
	                return this;
	            }
	        });
	    })();

	    /**
	     * Use this api to custom the species behavior.
	     * https://tc39.github.io/ecma262/#sec-speciesconstructor
	     * @param {Any} O The current this object.
	     * @param {Function} defaultConstructor
	     */
	    Yaku.speciesConstructor = function (O, D) {
	        var C = O.constructor;

	        return C ? C[getSpecies()] || D : D;
	    };

	    /**
	     * Catch all possibly unhandled rejections. If you want to use specific
	     * format to display the error stack, overwrite it.
	     * If it is set, auto `console.error` unhandled rejection will be disabled.
	     * @param {Any} reason The rejection reason.
	     * @param {Yaku} p The promise that was rejected.
	     * @example
	     * ```js
	     * var Promise = require('yaku');
	     * Promise.onUnhandledRejection = (reason) => {
	     *     console.error(reason);
	     * };
	     *
	     * // The console will log an unhandled rejection error message.
	     * Promise.reject('my reason');
	     *
	     * // The below won't log the unhandled rejection error message.
	     * Promise.reject('v').catch(() => {});
	     * ```
	     */
	    Yaku.unhandledRejection = function (reason, p) {
	        try {
	            root.console.error($unhandledRejectionMsg, genStackInfo(reason, p));
	        } catch (e) {} // eslint-disable-line
	    };

	    /**
	     * Emitted whenever a Promise was rejected and an error handler was
	     * attached to it (for example with .catch()) later than after an event loop turn.
	     * @param {Any} reason The rejection reason.
	     * @param {Yaku} p The promise that was rejected.
	     */
	    Yaku.rejectionHandled = $noop;

	    /**
	     * It is used to enable the long stack trace.
	     * Once it is enabled, it can't be reverted.
	     * While it is very helpful in development and testing environments,
	     * it is not recommended to use it in production. It will slow down your
	     * application and waste your memory.
	     * @example
	     * ```js
	     * var Promise = require('yaku');
	     * Promise.enableLongStackTrace();
	     * ```
	     */
	    Yaku.enableLongStackTrace = function () {
	        isLongStackTrace = true;
	    };

	    /**
	     * Only Node has `process.nextTick` function. For browser there are
	     * so many ways to polyfill it. Yaku won't do it for you, instead you
	     * can choose what you prefer. For example, this project
	     * [setImmediate](https://github.com/YuzuJS/setImmediate).
	     * By default, Yaku will use `process.nextTick` on Node, `setTimeout` on browser.
	     * @type {Function}
	     * @example
	     * ```js
	     * var Promise = require('yaku');
	     * Promise.nextTick = fn => window.setImmediate(fn);
	     * ```
	     * @example
	     * You can even use sync resolution if you really know what you are doing.
	     * ```js
	     * var Promise = require('yaku');
	     * Promise.nextTick = fn => fn();
	     * ```
	     */
	    Yaku.nextTick = process ? process.nextTick : function (fn) {
	        setTimeout(fn);
	    };

	    // ********************** Private **********************

	    Yaku._Yaku = 1;

	    /**
	     * All static variable name will begin with `$`. Such as `$rejected`.
	     * @private
	     */

	    // ******************************* Utils ********************************

	    function getSpecies() {
	        return Yaku[$Symbol][$species] || $speciesKey;
	    }

	    function extendPrototype(src, target) {
	        for (var k in target) {
	            src.prototype[k] = target[k];
	        }
	        return src;
	    }

	    function isObject(obj) {
	        return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object";
	    }

	    function isFunction(obj) {
	        return typeof obj === "function";
	    }

	    function isInstanceOf(a, b) {
	        return a instanceof b;
	    }

	    function isError(obj) {
	        return isInstanceOf(obj, Err);
	    }

	    function ensureType(obj, fn, msg) {
	        if (!fn(obj)) throw genTypeError(msg);
	    }

	    /**
	     * Wrap a function into a try-catch.
	     * @private
	     * @return {Any | $tryErr}
	     */
	    function tryCatcher() {
	        try {
	            return $tryCatchFn.apply($tryCatchThis, arguments);
	        } catch (e) {
	            $tryErr.e = e;
	            return $tryErr;
	        }
	    }

	    /**
	     * Generate a try-catch wrapped function.
	     * @private
	     * @param  {Function} fn
	     * @return {Function}
	     */
	    function genTryCatcher(fn, self) {
	        $tryCatchFn = fn;
	        $tryCatchThis = self;
	        return tryCatcher;
	    }

	    /**
	     * Generate a scheduler.
	     * @private
	     * @param  {Integer}  initQueueSize
	     * @param  {Function} fn `(Yaku, Value) ->` The schedule handler.
	     * @return {Function} `(Yaku, Value) ->` The scheduler.
	     */
	    function genScheduler(initQueueSize, fn) {
	        /**
	         * All async promise will be scheduled in
	         * here, so that they can be execute on the next tick.
	         * @private
	         */
	        var fnQueue = Arr(initQueueSize),
	            fnQueueLen = 0;

	        /**
	         * Run all queued functions.
	         * @private
	         */
	        function flush() {
	            var i = 0;
	            while (i < fnQueueLen) {
	                fn(fnQueue[i], fnQueue[i + 1]);
	                fnQueue[i++] = $undefined;
	                fnQueue[i++] = $undefined;
	            }

	            fnQueueLen = 0;
	            if (fnQueue.length > initQueueSize) fnQueue.length = initQueueSize;
	        }

	        return function (v, arg) {
	            fnQueue[fnQueueLen++] = v;
	            fnQueue[fnQueueLen++] = arg;

	            if (fnQueueLen === 2) Yaku.nextTick(flush);
	        };
	    }

	    /**
	     * Generate a iterator
	     * @param  {Any} obj
	     * @private
	     * @return {Object || TypeError}
	     */
	    function each(iterable, fn) {
	        var len,
	            i = 0,
	            iter,
	            item,
	            ret;

	        if (!iterable) throw genTypeError($invalidArgument);

	        var gen = iterable[Yaku[$Symbol][$iterator]];
	        if (isFunction(gen)) iter = gen.call(iterable);else if (isFunction(iterable.next)) iter = iterable;else if (isInstanceOf(iterable, Arr)) {
	            len = iterable.length;
	            while (i < len) {
	                fn(iterable[i], i++);
	            }
	            return i;
	        } else throw genTypeError($invalidArgument);

	        while (!(item = iter.next()).done) {
	            ret = genTryCatcher(fn)(item.value, i++);
	            if (ret === $tryErr) {
	                if (isFunction(iter[$return])) iter[$return]();
	                throw ret.e;
	            }
	        }

	        return i;
	    }

	    /**
	     * Generate type error object.
	     * @private
	     * @param  {String} msg
	     * @return {TypeError}
	     */
	    function genTypeError(msg) {
	        return new TypeError(msg);
	    }

	    function genTraceInfo(noTitle) {
	        return (noTitle ? "" : $fromPrevious) + (new Err().stack || "");
	    }

	    // *************************** Promise Helpers ****************************

	    /**
	     * Resolve the value returned by onFulfilled or onRejected.
	     * @private
	     * @param {Yaku} p1
	     * @param {Yaku} p2
	     */
	    var scheduleHandler = genScheduler(999, function (p1, p2) {
	        var x, handler;

	        // 2.2.2
	        // 2.2.3
	        handler = p1._s ? p2._onFulfilled : p2._onRejected;

	        // 2.2.7.3
	        // 2.2.7.4
	        if (handler === $undefined) {
	            settlePromise(p2, p1._s, p1._v);
	            return;
	        }

	        // 2.2.7.1
	        x = genTryCatcher(callHanler)(handler, p1._v);
	        if (x === $tryErr) {
	            // 2.2.7.2
	            settlePromise(p2, $rejected, x.e);
	            return;
	        }

	        settleWithX(p2, x);
	    });

	    var scheduleUnhandledRejection = genScheduler(9, function (p) {
	        if (!hashOnRejected(p)) {
	            p[$unhandled] = 1;
	            emitEvent($unhandledRejection, p);
	        }
	    });

	    function emitEvent(name, p) {
	        var browserEventName = "on" + name.toLowerCase(),
	            browserHandler = root[browserEventName];

	        if (process && process.listeners(name).length) name === $unhandledRejection ? process.emit(name, p._v, p) : process.emit(name, p);else if (browserHandler) browserHandler({ reason: p._v, promise: p });else Yaku[name](p._v, p);
	    }

	    function isYaku(val) {
	        return val && val._Yaku;
	    }

	    function newCapablePromise(Constructor) {
	        if (isYaku(Constructor)) return new Constructor($noop);

	        var p, r, j;
	        p = new Constructor(function (resolve, reject) {
	            if (p) throw genTypeError();

	            r = resolve;
	            j = reject;
	        });

	        ensureType(r, isFunction);
	        ensureType(j, isFunction);

	        return p;
	    }

	    /**
	     * It will produce a settlePromise function to user.
	     * Such as the resolve and reject in this `new Yaku (resolve, reject) ->`.
	     * @private
	     * @param  {Yaku} self
	     * @param  {Integer} state The value is one of `$pending`, `$resolved` or `$rejected`.
	     * @return {Function} `(value) -> undefined` A resolve or reject function.
	     */
	    function genSettler(self, state) {
	        return function (value) {
	            if (isLongStackTrace) self[$settlerTrace] = genTraceInfo(true);

	            if (state === $resolved) settleWithX(self, value);else settlePromise(self, state, value);
	        };
	    }

	    /**
	     * Link the promise1 to the promise2.
	     * @private
	     * @param {Yaku} p1
	     * @param {Yaku} p2
	     * @param {Function} onFulfilled
	     * @param {Function} onRejected
	     */
	    function addHandler(p1, p2, onFulfilled, onRejected) {
	        // 2.2.1
	        if (isFunction(onFulfilled)) p2._onFulfilled = onFulfilled;
	        if (isFunction(onRejected)) {
	            if (p1[$unhandled]) emitEvent($rejectionHandled, p1);

	            p2._onRejected = onRejected;
	        }

	        if (isLongStackTrace) p2._pre = p1;
	        p1[p1._pCount++] = p2;

	        // 2.2.6
	        if (p1._s !== $pending) scheduleHandler(p1, p2);

	        // 2.2.7
	        return p2;
	    }

	    // iterate tree
	    function hashOnRejected(node) {
	        // A node shouldn't be checked twice.
	        if (node._umark) return true;else node._umark = true;

	        var i = 0,
	            len = node._pCount,
	            child;

	        while (i < len) {
	            child = node[i++];
	            if (child._onRejected || hashOnRejected(child)) return true;
	        }
	    }

	    function genStackInfo(reason, p) {
	        var stackInfo = [];

	        function push(trace) {
	            return stackInfo.push(trace.replace(/^\s+|\s+$/g, ""));
	        }

	        if (isLongStackTrace) {
	            if (p[$settlerTrace]) push(p[$settlerTrace]);

	            // Hope you guys could understand how the back trace works.
	            // We only have to iterate through the tree from the bottom to root.
	            (function iter(node) {
	                if (node && $promiseTrace in node) {
	                    iter(node._next);
	                    push(node[$promiseTrace]);
	                    iter(node._pre);
	                }
	            })(p);
	        }

	        return (isError(reason) ? reason.stack : reason) + ("\n" + stackInfo.join("\n")).replace(/^.+\/node_modules\/yaku\/.+\n?/mg, "");
	    }

	    function callHanler(handler, value) {
	        // 2.2.5
	        return handler(value);
	    }

	    /**
	     * Resolve or reject a promise.
	     * @private
	     * @param  {Yaku} p
	     * @param  {Integer} state
	     * @param  {Any} value
	     */
	    function settlePromise(p, state, value) {
	        var i = 0,
	            len = p._pCount,
	            p2;

	        // 2.1.2
	        // 2.1.3
	        if (p._s === $pending) {
	            // 2.1.1.1
	            p._s = state;
	            p._v = value;

	            if (state === $rejected) {
	                if (isLongStackTrace && isError(value)) {
	                    value.longStack = genStackInfo(value, p);
	                }

	                scheduleUnhandledRejection(p);
	            }

	            // 2.2.4
	            while (i < len) {
	                p2 = p[i++];

	                if (p2._s !== $pending) continue;

	                scheduleHandler(p, p2);
	            }
	        }

	        return p;
	    }

	    /**
	     * Resolve or reject promise with value x. The x can also be a thenable.
	     * @private
	     * @param {Yaku} p
	     * @param {Any | Thenable} x A normal value or a thenable.
	     */
	    function settleWithX(p, x) {
	        // 2.3.1
	        if (x === p && x) {
	            settlePromise(p, $rejected, genTypeError($promiseCircularChain));
	            return p;
	        }

	        // 2.3.2
	        // 2.3.3
	        if (x !== $null && (isFunction(x) || isObject(x))) {
	            // 2.3.2.1
	            var xthen = genTryCatcher(getThen)(x);

	            if (xthen === $tryErr) {
	                // 2.3.3.2
	                settlePromise(p, $rejected, xthen.e);
	                return p;
	            }

	            if (isFunction(xthen)) {
	                if (isLongStackTrace && isYaku(x)) p._next = x;

	                // Fix https://bugs.chromium.org/p/v8/issues/detail?id=4162
	                if (isYaku(x)) settleXthen(p, x, xthen);else Yaku.nextTick(function () {
	                    settleXthen(p, x, xthen);
	                });
	            } else
	                // 2.3.3.4
	                settlePromise(p, $resolved, x);
	        } else
	            // 2.3.4
	            settlePromise(p, $resolved, x);

	        return p;
	    }

	    /**
	     * Try to get a promise's then method.
	     * @private
	     * @param  {Thenable} x
	     * @return {Function}
	     */
	    function getThen(x) {
	        return x.then;
	    }

	    /**
	     * Resolve then with its promise.
	     * @private
	     * @param  {Yaku} p
	     * @param  {Thenable} x
	     * @param  {Function} xthen
	     */
	    function settleXthen(p, x, xthen) {
	        // 2.3.3.3
	        var err = genTryCatcher(xthen, x)(function (y) {
	            // 2.3.3.3.3
	            if (x) {
	                x = $null;

	                // 2.3.3.3.1
	                settleWithX(p, y);
	            }
	        }, function (r) {
	            // 2.3.3.3.3
	            if (x) {
	                x = $null;

	                // 2.3.3.3.2
	                settlePromise(p, $rejected, r);
	            }
	        });

	        // 2.3.3.3.4.1
	        if (err === $tryErr && x) {
	            // 2.3.3.3.4.2
	            settlePromise(p, $rejected, err.e);
	            x = $null;
	        }
	    }
	})();
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var require;var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, global, module) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   3.2.1
	 */

	(function () {
	  "use strict";

	  function lib$es6$promise$utils$$objectOrFunction(x) {
	    return typeof x === 'function' || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null;
	  }

	  function lib$es6$promise$utils$$isFunction(x) {
	    return typeof x === 'function';
	  }

	  function lib$es6$promise$utils$$isMaybeThenable(x) {
	    return (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && x !== null;
	  }

	  var lib$es6$promise$utils$$_isArray;
	  if (!Array.isArray) {
	    lib$es6$promise$utils$$_isArray = function lib$es6$promise$utils$$_isArray(x) {
	      return Object.prototype.toString.call(x) === '[object Array]';
	    };
	  } else {
	    lib$es6$promise$utils$$_isArray = Array.isArray;
	  }

	  var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	  var lib$es6$promise$asap$$len = 0;
	  var lib$es6$promise$asap$$vertxNext;
	  var lib$es6$promise$asap$$customSchedulerFn;

	  var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	    lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	    lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	    lib$es6$promise$asap$$len += 2;
	    if (lib$es6$promise$asap$$len === 2) {
	      // If len is 2, that means that we need to schedule an async flush.
	      // If additional callbacks are queued before the queue is flushed, they
	      // will be processed by this flush that we are scheduling.
	      if (lib$es6$promise$asap$$customSchedulerFn) {
	        lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	      } else {
	        lib$es6$promise$asap$$scheduleFlush();
	      }
	    }
	  };

	  function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	    lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	  }

	  function lib$es6$promise$asap$$setAsap(asapFn) {
	    lib$es6$promise$asap$$asap = asapFn;
	  }

	  var lib$es6$promise$asap$$browserWindow = typeof window !== 'undefined' ? window : undefined;
	  var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	  var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	  var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

	  // test for web worker but not in IE10
	  var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

	  // node
	  function lib$es6$promise$asap$$useNextTick() {
	    // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	    // see https://github.com/cujojs/when/issues/410 for details
	    return function () {
	      process.nextTick(lib$es6$promise$asap$$flush);
	    };
	  }

	  // vertx
	  function lib$es6$promise$asap$$useVertxTimer() {
	    return function () {
	      lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	    };
	  }

	  function lib$es6$promise$asap$$useMutationObserver() {
	    var iterations = 0;
	    var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	    var node = document.createTextNode('');
	    observer.observe(node, { characterData: true });

	    return function () {
	      node.data = iterations = ++iterations % 2;
	    };
	  }

	  // web worker
	  function lib$es6$promise$asap$$useMessageChannel() {
	    var channel = new MessageChannel();
	    channel.port1.onmessage = lib$es6$promise$asap$$flush;
	    return function () {
	      channel.port2.postMessage(0);
	    };
	  }

	  function lib$es6$promise$asap$$useSetTimeout() {
	    return function () {
	      setTimeout(lib$es6$promise$asap$$flush, 1);
	    };
	  }

	  var lib$es6$promise$asap$$queue = new Array(1000);
	  function lib$es6$promise$asap$$flush() {
	    for (var i = 0; i < lib$es6$promise$asap$$len; i += 2) {
	      var callback = lib$es6$promise$asap$$queue[i];
	      var arg = lib$es6$promise$asap$$queue[i + 1];

	      callback(arg);

	      lib$es6$promise$asap$$queue[i] = undefined;
	      lib$es6$promise$asap$$queue[i + 1] = undefined;
	    }

	    lib$es6$promise$asap$$len = 0;
	  }

	  function lib$es6$promise$asap$$attemptVertx() {
	    try {
	      var r = require;
	      var vertx = __webpack_require__(35);
	      lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	      return lib$es6$promise$asap$$useVertxTimer();
	    } catch (e) {
	      return lib$es6$promise$asap$$useSetTimeout();
	    }
	  }

	  var lib$es6$promise$asap$$scheduleFlush;
	  // Decide what async method to use to triggering processing of queued callbacks:
	  if (lib$es6$promise$asap$$isNode) {
	    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	  } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	  } else if (lib$es6$promise$asap$$isWorker) {
	    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	  } else if (lib$es6$promise$asap$$browserWindow === undefined && "function" === 'function') {
	    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
	  } else {
	    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	  }
	  function lib$es6$promise$then$$then(onFulfillment, onRejection) {
	    var parent = this;

	    var child = new this.constructor(lib$es6$promise$$internal$$noop);

	    if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {
	      lib$es6$promise$$internal$$makePromise(child);
	    }

	    var state = parent._state;

	    if (state) {
	      var callback = arguments[state - 1];
	      lib$es6$promise$asap$$asap(function () {
	        lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);
	      });
	    } else {
	      lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	    }

	    return child;
	  }
	  var lib$es6$promise$then$$default = lib$es6$promise$then$$then;
	  function lib$es6$promise$promise$resolve$$resolve(object) {
	    /*jshint validthis:true */
	    var Constructor = this;

	    if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.constructor === Constructor) {
	      return object;
	    }

	    var promise = new Constructor(lib$es6$promise$$internal$$noop);
	    lib$es6$promise$$internal$$resolve(promise, object);
	    return promise;
	  }
	  var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	  var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);

	  function lib$es6$promise$$internal$$noop() {}

	  var lib$es6$promise$$internal$$PENDING = void 0;
	  var lib$es6$promise$$internal$$FULFILLED = 1;
	  var lib$es6$promise$$internal$$REJECTED = 2;

	  var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

	  function lib$es6$promise$$internal$$selfFulfillment() {
	    return new TypeError("You cannot resolve a promise with itself");
	  }

	  function lib$es6$promise$$internal$$cannotReturnOwn() {
	    return new TypeError('A promises callback cannot return that same promise.');
	  }

	  function lib$es6$promise$$internal$$getThen(promise) {
	    try {
	      return promise.then;
	    } catch (error) {
	      lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	      return lib$es6$promise$$internal$$GET_THEN_ERROR;
	    }
	  }

	  function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	    try {
	      then.call(value, fulfillmentHandler, rejectionHandler);
	    } catch (e) {
	      return e;
	    }
	  }

	  function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	    lib$es6$promise$asap$$asap(function (promise) {
	      var sealed = false;
	      var error = lib$es6$promise$$internal$$tryThen(then, thenable, function (value) {
	        if (sealed) {
	          return;
	        }
	        sealed = true;
	        if (thenable !== value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, value);
	        }
	      }, function (reason) {
	        if (sealed) {
	          return;
	        }
	        sealed = true;

	        lib$es6$promise$$internal$$reject(promise, reason);
	      }, 'Settle: ' + (promise._label || ' unknown promise'));

	      if (!sealed && error) {
	        sealed = true;
	        lib$es6$promise$$internal$$reject(promise, error);
	      }
	    }, promise);
	  }

	  function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	    if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	      lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	    } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	      lib$es6$promise$$internal$$reject(promise, thenable._result);
	    } else {
	      lib$es6$promise$$internal$$subscribe(thenable, undefined, function (value) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      }, function (reason) {
	        lib$es6$promise$$internal$$reject(promise, reason);
	      });
	    }
	  }

	  function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {
	    if (maybeThenable.constructor === promise.constructor && then === lib$es6$promise$then$$default && constructor.resolve === lib$es6$promise$promise$resolve$$default) {
	      lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	    } else {
	      if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	      } else if (then === undefined) {
	        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	      } else if (lib$es6$promise$utils$$isFunction(then)) {
	        lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	      }
	    }
	  }

	  function lib$es6$promise$$internal$$resolve(promise, value) {
	    if (promise === value) {
	      lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
	    } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	      lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));
	    } else {
	      lib$es6$promise$$internal$$fulfill(promise, value);
	    }
	  }

	  function lib$es6$promise$$internal$$publishRejection(promise) {
	    if (promise._onerror) {
	      promise._onerror(promise._result);
	    }

	    lib$es6$promise$$internal$$publish(promise);
	  }

	  function lib$es6$promise$$internal$$fulfill(promise, value) {
	    if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	      return;
	    }

	    promise._result = value;
	    promise._state = lib$es6$promise$$internal$$FULFILLED;

	    if (promise._subscribers.length !== 0) {
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	    }
	  }

	  function lib$es6$promise$$internal$$reject(promise, reason) {
	    if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	      return;
	    }
	    promise._state = lib$es6$promise$$internal$$REJECTED;
	    promise._result = reason;

	    lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	  }

	  function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	    var subscribers = parent._subscribers;
	    var length = subscribers.length;

	    parent._onerror = null;

	    subscribers[length] = child;
	    subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	    subscribers[length + lib$es6$promise$$internal$$REJECTED] = onRejection;

	    if (length === 0 && parent._state) {
	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	    }
	  }

	  function lib$es6$promise$$internal$$publish(promise) {
	    var subscribers = promise._subscribers;
	    var settled = promise._state;

	    if (subscribers.length === 0) {
	      return;
	    }

	    var child,
	        callback,
	        detail = promise._result;

	    for (var i = 0; i < subscribers.length; i += 3) {
	      child = subscribers[i];
	      callback = subscribers[i + settled];

	      if (child) {
	        lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	      } else {
	        callback(detail);
	      }
	    }

	    promise._subscribers.length = 0;
	  }

	  function lib$es6$promise$$internal$$ErrorObject() {
	    this.error = null;
	  }

	  var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

	  function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	    try {
	      return callback(detail);
	    } catch (e) {
	      lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	      return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	    }
	  }

	  function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	    var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	        value,
	        error,
	        succeeded,
	        failed;

	    if (hasCallback) {
	      value = lib$es6$promise$$internal$$tryCatch(callback, detail);

	      if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	        failed = true;
	        error = value.error;
	        value = null;
	      } else {
	        succeeded = true;
	      }

	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	        return;
	      }
	    } else {
	      value = detail;
	      succeeded = true;
	    }

	    if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	      // noop
	    } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	  }

	  function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	    try {
	      resolver(function resolvePromise(value) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      }, function rejectPromise(reason) {
	        lib$es6$promise$$internal$$reject(promise, reason);
	      });
	    } catch (e) {
	      lib$es6$promise$$internal$$reject(promise, e);
	    }
	  }

	  var lib$es6$promise$$internal$$id = 0;
	  function lib$es6$promise$$internal$$nextId() {
	    return lib$es6$promise$$internal$$id++;
	  }

	  function lib$es6$promise$$internal$$makePromise(promise) {
	    promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;
	    promise._state = undefined;
	    promise._result = undefined;
	    promise._subscribers = [];
	  }

	  function lib$es6$promise$promise$all$$all(entries) {
	    return new lib$es6$promise$enumerator$$default(this, entries).promise;
	  }
	  var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	  function lib$es6$promise$promise$race$$race(entries) {
	    /*jshint validthis:true */
	    var Constructor = this;

	    if (!lib$es6$promise$utils$$isArray(entries)) {
	      return new Constructor(function (resolve, reject) {
	        reject(new TypeError('You must pass an array to race.'));
	      });
	    } else {
	      return new Constructor(function (resolve, reject) {
	        var length = entries.length;
	        for (var i = 0; i < length; i++) {
	          Constructor.resolve(entries[i]).then(resolve, reject);
	        }
	      });
	    }
	  }
	  var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	  function lib$es6$promise$promise$reject$$reject(reason) {
	    /*jshint validthis:true */
	    var Constructor = this;
	    var promise = new Constructor(lib$es6$promise$$internal$$noop);
	    lib$es6$promise$$internal$$reject(promise, reason);
	    return promise;
	  }
	  var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

	  function lib$es6$promise$promise$$needsResolver() {
	    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	  }

	  function lib$es6$promise$promise$$needsNew() {
	    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	  }

	  var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	  /**
	    Promise objects represent the eventual result of an asynchronous operation. The
	    primary way of interacting with a promise is through its `then` method, which
	    registers callbacks to receive either a promise's eventual value or the reason
	    why the promise cannot be fulfilled.
	     Terminology
	    -----------
	     - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	    - `thenable` is an object or function that defines a `then` method.
	    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	    - `exception` is a value that is thrown using the throw statement.
	    - `reason` is a value that indicates why a promise was rejected.
	    - `settled` the final resting state of a promise, fulfilled or rejected.
	     A promise can be in one of three states: pending, fulfilled, or rejected.
	     Promises that are fulfilled have a fulfillment value and are in the fulfilled
	    state.  Promises that are rejected have a rejection reason and are in the
	    rejected state.  A fulfillment value is never a thenable.
	     Promises can also be said to *resolve* a value.  If this value is also a
	    promise, then the original promise's settled state will match the value's
	    settled state.  So a promise that *resolves* a promise that rejects will
	    itself reject, and a promise that *resolves* a promise that fulfills will
	    itself fulfill.
	      Basic Usage:
	    ------------
	     ```js
	    var promise = new Promise(function(resolve, reject) {
	      // on success
	      resolve(value);
	       // on failure
	      reject(reason);
	    });
	     promise.then(function(value) {
	      // on fulfillment
	    }, function(reason) {
	      // on rejection
	    });
	    ```
	     Advanced Usage:
	    ---------------
	     Promises shine when abstracting away asynchronous interactions such as
	    `XMLHttpRequest`s.
	     ```js
	    function getJSON(url) {
	      return new Promise(function(resolve, reject){
	        var xhr = new XMLHttpRequest();
	         xhr.open('GET', url);
	        xhr.onreadystatechange = handler;
	        xhr.responseType = 'json';
	        xhr.setRequestHeader('Accept', 'application/json');
	        xhr.send();
	         function handler() {
	          if (this.readyState === this.DONE) {
	            if (this.status === 200) {
	              resolve(this.response);
	            } else {
	              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	            }
	          }
	        };
	      });
	    }
	     getJSON('/posts.json').then(function(json) {
	      // on fulfillment
	    }, function(reason) {
	      // on rejection
	    });
	    ```
	     Unlike callbacks, promises are great composable primitives.
	     ```js
	    Promise.all([
	      getJSON('/posts'),
	      getJSON('/comments')
	    ]).then(function(values){
	      values[0] // => postsJSON
	      values[1] // => commentsJSON
	       return values;
	    });
	    ```
	     @class Promise
	    @param {function} resolver
	    Useful for tooling.
	    @constructor
	  */
	  function lib$es6$promise$promise$$Promise(resolver) {
	    this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();
	    this._result = this._state = undefined;
	    this._subscribers = [];

	    if (lib$es6$promise$$internal$$noop !== resolver) {
	      typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();
	      this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();
	    }
	  }

	  lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	  lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	  lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	  lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	  lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	  lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	  lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

	  lib$es6$promise$promise$$Promise.prototype = {
	    constructor: lib$es6$promise$promise$$Promise,

	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.
	       ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```
	       Chaining
	      --------
	       The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.
	       ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });
	       findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	       ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```
	       Assimilation
	      ------------
	       Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.
	       ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```
	       If the assimliated promise rejects, then the downstream promise will also reject.
	       ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```
	       Simple Example
	      --------------
	       Synchronous Example
	       ```javascript
	      var result;
	       try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	       Errback Example
	       ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```
	       Promise Example;
	       ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```
	       Advanced Example
	      --------------
	       Synchronous Example
	       ```javascript
	      var author, books;
	       try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```
	       Errback Example
	       ```js
	       function foundBooks(books) {
	       }
	       function failure(reason) {
	       }
	       findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```
	       Promise Example;
	       ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```
	       @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	    then: lib$es6$promise$then$$default,

	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.
	       ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }
	       // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }
	       // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```
	       @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	    'catch': function _catch(onRejection) {
	      return this.then(null, onRejection);
	    }
	  };
	  var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;
	  function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	    this._instanceConstructor = Constructor;
	    this.promise = new Constructor(lib$es6$promise$$internal$$noop);

	    if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {
	      lib$es6$promise$$internal$$makePromise(this.promise);
	    }

	    if (lib$es6$promise$utils$$isArray(input)) {
	      this._input = input;
	      this.length = input.length;
	      this._remaining = input.length;

	      this._result = new Array(this.length);

	      if (this.length === 0) {
	        lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	      } else {
	        this.length = this.length || 0;
	        this._enumerate();
	        if (this._remaining === 0) {
	          lib$es6$promise$$internal$$fulfill(this.promise, this._result);
	        }
	      }
	    } else {
	      lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());
	    }
	  }

	  function lib$es6$promise$enumerator$$validationError() {
	    return new Error('Array Methods must be provided an Array');
	  }

	  lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function () {
	    var length = this.length;
	    var input = this._input;

	    for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	      this._eachEntry(input[i], i);
	    }
	  };

	  lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function (entry, i) {
	    var c = this._instanceConstructor;
	    var resolve = c.resolve;

	    if (resolve === lib$es6$promise$promise$resolve$$default) {
	      var then = lib$es6$promise$$internal$$getThen(entry);

	      if (then === lib$es6$promise$then$$default && entry._state !== lib$es6$promise$$internal$$PENDING) {
	        this._settledAt(entry._state, i, entry._result);
	      } else if (typeof then !== 'function') {
	        this._remaining--;
	        this._result[i] = entry;
	      } else if (c === lib$es6$promise$promise$$default) {
	        var promise = new c(lib$es6$promise$$internal$$noop);
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);
	        this._willSettleAt(promise, i);
	      } else {
	        this._willSettleAt(new c(function (resolve) {
	          resolve(entry);
	        }), i);
	      }
	    } else {
	      this._willSettleAt(resolve(entry), i);
	    }
	  };

	  lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function (state, i, value) {
	    var promise = this.promise;

	    if (promise._state === lib$es6$promise$$internal$$PENDING) {
	      this._remaining--;

	      if (state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      } else {
	        this._result[i] = value;
	      }
	    }

	    if (this._remaining === 0) {
	      lib$es6$promise$$internal$$fulfill(promise, this._result);
	    }
	  };

	  lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function (promise, i) {
	    var enumerator = this;

	    lib$es6$promise$$internal$$subscribe(promise, undefined, function (value) {
	      enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	    }, function (reason) {
	      enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	    });
	  };
	  function lib$es6$promise$polyfill$$polyfill() {
	    var local;

	    if (typeof global !== 'undefined') {
	      local = global;
	    } else if (typeof self !== 'undefined') {
	      local = self;
	    } else {
	      try {
	        local = Function('return this')();
	      } catch (e) {
	        throw new Error('polyfill failed because global object is unavailable in this environment');
	      }
	    }

	    var P = local.Promise;

	    if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	      return;
	    }

	    local.Promise = lib$es6$promise$promise$$default;
	  }
	  var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

	  var lib$es6$promise$umd$$ES6Promise = {
	    'Promise': lib$es6$promise$promise$$default,
	    'polyfill': lib$es6$promise$polyfill$$default
	  };

	  /* global define:true module:true window: true */
	  if ("function" === 'function' && __webpack_require__(17)['amd']) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return lib$es6$promise$umd$$ES6Promise;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof module !== 'undefined' && module['exports']) {
	    module['exports'] = lib$es6$promise$umd$$ES6Promise;
	  } else if (typeof this !== 'undefined') {
	    this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	  }

	  lib$es6$promise$polyfill$$default();
	}).call(undefined);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), (function() { return this; }()), __webpack_require__(12)(module)))

/***/ },
/* 35 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ }
/******/ ]);